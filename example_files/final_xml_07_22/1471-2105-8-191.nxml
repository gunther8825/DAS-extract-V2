<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Archiving and Interchange DTD v2.3 20070202//EN" "archivearticle.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="product-review"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-title>BMC Bioinformatics</journal-title><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name><publisher-loc>London</publisher-loc></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">17559666</article-id><article-id pub-id-type="pmc">1913543</article-id><article-id pub-id-type="publisher-id">1471-2105-8-191</article-id><article-id pub-id-type="doi">10.1186/1471-2105-8-191</article-id><article-categories><subj-group subj-group-type="heading"><subject>Software</subject></subj-group></article-categories><title-group><article-title>Bio::NEXUS: a Perl API for the NEXUS format for comparative biological data</article-title></title-group><contrib-group><contrib id="A1" contrib-type="author"><name><surname>Hladish</surname><given-names>Thomas</given-names></name><xref ref-type="aff" rid="I1">1</xref><xref ref-type="aff" rid="I2">2</xref><email>tjhladish@mail.utexas.edu</email></contrib><contrib id="A2" equal-contrib="yes" contrib-type="author"><name><surname>Gopalan</surname><given-names>Vivek</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>gopalan@umbi.umd.edu</email></contrib><contrib id="A3" equal-contrib="yes" contrib-type="author"><name><surname>Liang</surname><given-names>Chengzhi</given-names></name><xref ref-type="aff" rid="I1">1</xref><xref ref-type="aff" rid="I3">3</xref><email>liang@cshl.edu</email></contrib><contrib id="A4" equal-contrib="yes" contrib-type="author"><name><surname>Qiu</surname><given-names>Weigang</given-names></name><xref ref-type="aff" rid="I1">1</xref><xref ref-type="aff" rid="I4">4</xref><email>weigang@genectr.hunter.cuny.edu</email></contrib><contrib id="A5" contrib-type="author"><name><surname>Yang</surname><given-names>Peter</given-names></name><xref ref-type="aff" rid="I1">1</xref><email>pyang@alumni.rice.edu</email></contrib><contrib id="A6" corresp="yes" contrib-type="author"><name><surname>Stoltzfus</surname><given-names>Arlin</given-names></name><xref ref-type="aff" rid="I1">1</xref><xref ref-type="aff" rid="I5">5</xref><email>arlin.stoltzfus@nist.gov</email></contrib></contrib-group><aff id="I1"><label>1</label>Center for Advanced Research in Biotechnology, 9600 Gudelsky Drive, Rockville, MD 20850, USA</aff><aff id="I2"><label>2</label>Section of Integrative Biology, University of Texas at Austin, 1 University Station C0930, Austin, Texas 78712, USA</aff><aff id="I3"><label>3</label>Cold Spring Harbor Laboratory, 1 Bungtown Rd, Cold Spring Harbor, NY 11724, USA</aff><aff id="I4"><label>4</label>Department of Biological Sciences, Hunter College, CUNY, 695 Park Ave., New York, NY 10021, USA</aff><aff id="I5"><label>5</label>Biochemical Science Division, National Institute of Standards and Technology, Gaithersburg, MD 20899-8310, USA</aff><pub-date pub-type="collection"><year>2007</year></pub-date><pub-date pub-type="epub"><day>8</day><month>6</month><year>2007</year></pub-date><volume>8</volume><fpage>191</fpage><lpage>191</lpage><ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/8/191"/><history><date date-type="received"><day>28</day><month>2</month><year>2007</year></date><date date-type="accepted"><day>8</day><month>6</month><year>2007</year></date></history><permissions><copyright-statement>Copyright &#x000a9; 2007 Hladish et al; licensee BioMed Central Ltd.</copyright-statement><copyright-year>2007</copyright-year><copyright-holder>Hladish et al; licensee BioMed Central Ltd.</copyright-holder><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0"><p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p><!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>
               Hladish
               Thomas
               
               
               tjhladish@mail.utexas.edu
            </dc:author><dc:title>
            Bio::NEXUS: a Perl API for the NEXUS format for comparative biological data
         </dc:title><dc:date>2007</dc:date><dcterms:bibliographicCitation>BMC Bioinformatics 8(1): 191-. (2007)</dcterms:bibliographicCitation><dc:identifier type="sici">1471-2105(2007)8:1&#x0003c;191&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1471-2105</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>--></license></permissions><abstract><sec><title>Background</title><p>Evolutionary analysis provides a formal framework for comparative analysis of genomic and other data. In evolutionary analysis, observed data are treated as the terminal states of characters that have evolved (via transitions between states) along the branches of a tree. The NEXUS standard of Maddison, et al. (1997; <italic>Syst. Biol</italic>. 46: 590&#x02013;621) provides a portable, expressive and flexible text format for representing character-state data and trees. However, due to its complexity, NEXUS is not well supported by software and is not easily accessible to bioinformatics users and developers.</p></sec><sec><title>Results</title><p>Bio::NEXUS is an application programming interface (API) implemented in Perl, available from CPAN and SourceForge. The 22 Bio::NEXUS modules define 351 methods in 4229 lines of code, with 2706 lines of POD (Plain Old Documentation). Bio::NEXUS provides an object-oriented interface to reading, writing and manipulating the contents of NEXUS files. It closely follows the extensive explanation of the NEXUS format provided by Maddison et al., supplemented with a few extensions such as support for the NHX (New Hampshire Extended) tree format.</p></sec><sec><title>Conclusion</title><p>In spite of some limitations owing to the complexity of NEXUS files and the lack of a formal grammar, NEXUS will continue to be useful for years to come. Bio::NEXUS provides a user-friendly API for NEXUS supplemented with an extensive set of methods for manipulations such as re-rooting trees and selecting subsets of data. Bio::NEXUS can be used as glue code for connecting existing software that uses NEXUS, or as a framework for new applications.</p></sec></abstract></article-meta></front><body><sec><title>Background</title><sec><title>Evolutionary comparative analysis</title><p>In comparative biology, inferences are made from patterns of similarities and differences. Contemporary genome analysis relies heavily on such comparisons, e.g., as in the way that human genome annotation has relied on comparisons with the mouse and chimp genomes. Evolutionary biologists have developed a specialized methodology for comparative analysis that draws on modern methods of statistical inference and that is (in principle) widely applicable to all sorts of biological data &#x02013; from molecular sequences and protein activities to morphologies and behaviours [<xref ref-type="bibr" rid="B1">1</xref>].</p><p>The evolutionary approach provides a framework to convert problems of how to analyze similarities and differences into well posed questions about rates of various possible evolutionary transitions along the branches of a tree (phylogeny). As genome analysis and other systematic types of comparative analysis mature, and researchers seek to extract the maximum amount of useful information from available data, these methods of "evolutionary comparative analysis" have become increasingly important [<xref ref-type="bibr" rid="B2">2</xref>,<xref ref-type="bibr" rid="B3">3</xref>].</p></sec><sec><title>The character-state data model</title><p>The methodological generality of evolutionary analysis relies on what we refer to here as "the character-state data model", a kind of Entity-Attribute-Value model. In the character-state data model, observations or measurements on a set of entities called "OTUs" (Operational Taxonomic Units) are represented as the observed values, called "states" (or "character states"), of a set of underlying attributes, called "characters". For a protein sequence alignment, for instance, each OTU (entity) is a protein, the homologous characters (attributes) are the alignment columns, and the state (value) of each OTU for a particular character is an amino acid or a gap (the latter often represented with the symbol "-"). Characters for which the states are finite are discrete characters; continuous characters are also possible (e.g,. beak length, protein activity). In biology, data sets often are incomplete, thus the state of a character may be denoted as "missing" (often represented with the symbol "?").</p><p>The assignment of characters is based on homology indicative of common ancestry. The presence of different states for the same (ancestral) character thus implies historical changes (transitions of state) from a common ancestral state. The paths of change are not all independent, but follow the branchings of a phylogenetic tree. That is, in evolutionary analysis, hierarchical clustering of data is not merely a heuristic tool, but reflects a generative model, an explicit or implicit model of character-state transitions that take place along the branches of a tree. The simplest model is that any change from one state to another observed state has the same probability or cost. More complex models may introduce restrictions on allowed transitions, or introduce non-uniform costs for possible transitions, or may relate the rates of transitions to a mechanistically inspired model (e.g., separate rate parameters for synonymous or non-synonymous changes).</p></sec><sec><title>The NEXUS format</title><p>NEXUS [<xref ref-type="bibr" rid="B4">4</xref>] is a data exchange file format for character-state data and trees, used in software such as Mesquite [<xref ref-type="bibr" rid="B5">5</xref>], PAUP* [<xref ref-type="bibr" rid="B6">6</xref>], and MrBayes [<xref ref-type="bibr" rid="B7">7</xref>]. The terminology used in NEXUS files, and in the NEXUS standard, draws on the implicit character-state data model, e.g., columns of comparative data are referred to as "characters" (e.g., they are stored in a "CHARACTERS" block, within which labels are assigned via the "charlabels" command), for which each OTU has a "state". Note, however, that the OTUs in a NEXUS file are referred to as "taxa" (thus, a "TAXA" block has a "taxlabels" command) rather than as "OTUs". Figure <xref ref-type="fig" rid="F1">1</xref> depicts the relationship between an example NEXUS dataset (Additional file <xref ref-type="supplementary-material" rid="S1">1</xref>) and the character-state-data model.</p><fig position="float" id="F1"><label>Figure 1</label><caption><p><bold>NEXUS and the character-state data model</bold>. Some relevant terms and concepts are illustrated with a graphical view of a small family of RAD23-related protein-coding genes (KOG0011 data provided in Additional file <xref ref-type="supplementary-material" rid="S1">1</xref>). In molecular sequence analyses, OTUs often are labelled with a token fusing a species name with a database ID. In a NEXUS file, such OTU labels are declared in a TAXA block. The TREES block may contain one or more trees relating the OTUs, each tree optionally having label (e.g., "Coelomate") and a numeric weight (e.g., a probability). Trees may contain branch lengths and support values. In the matrix of amino acid character data shown here, the 4<sup>th </sup>character (i.e., the 4<sup>th </sup>alignment column), has the states "V", "I", "I", "L", "V", "I", "L", and "I". Such character-state data are stored in a NEXUS CHARACTERS block, which defines the type of data and the meaning of a gap symbol such as "-". The ASSUMPTIONS block of a NEXUS file provides the means to store a weight or other numeric value for each character, such as the column-wise alignment scores shown here. Many other types of information not shown here can be stored in NEXUS files.</p></caption><graphic xlink:href="1471-2105-8-191-1"/></fig><p>While the name "NEXUS" is capitalized by convention, NEXUS keywords are (with few exceptions) case-insensitive. However, for purposes of clarity we capitalize the keywords used to designate NEXUS blocks, such as TAXA, CHARACTERS, and TREES.</p><p>Although NEXUS files initially were used mainly for morphological data, the developers of NEXUS allowed for diverse types of data, including provisions for such things as frequency distributions of states (for each OTU), as well as commands specific for molecular data, so as to specify codon locations and to define alternative genetic codes. As a result, NEXUS continues to provide a rich way to represent diverse types of data that might be used in a comparative analysis of genes, proteins, or genomes. NEXUS files often include several types of information, the most common being:</p><p>&#x02022; a discrete character matrix (e.g., a molecular sequence alignment)</p><p>&#x02022; a continuous character matrix</p><p>&#x02022; one or more rooted or unrooted phylogenies, each with (optional) name and weight</p><p>&#x02022; a distance matrix</p><p>&#x02022; a description of constraints on, or costs of, transitions between states of characters</p><p>&#x02022; other assumptions such as weights for characters</p><p>Within a NEXUS file, data are organized into blocks, such that (in general) one block corresponds to one type of data. The complete list of blocks is given (in order of importance) in Table <xref ref-type="table" rid="T1">1</xref>. The most commonly used blocks are TAXA (to define the set of OTUs), CHARACTERS (defining a set of character data) and TREES. The use of a DATA block &#x02013; essentially a CHARACTERS block for which the OTUs have not been pre-defined via a TAXA block &#x02013; is deprecated.</p><table-wrap position="float" id="T1"><label>Table 1</label><caption><p>NEXUS blocks and common commands</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="left"><bold>Block name</bold></td><td align="left"><bold>Commonly used commands</bold></td><td align="left"><bold>Typical content of block</bold></td></tr></thead><tbody><tr><td align="left"><bold>TAXA</bold></td><td align="left">dimensions, taxlabels</td><td align="left">Labels for OTUs (may be quoted strings)</td></tr><tr><td align="left"><bold>CHARACTERS</bold></td><td align="left">dimensions, format, matrix</td><td align="left">A matrix of character-state data (e.g., aligned residues) of defined type, in a defined format</td></tr><tr><td align="left"><bold>TREES</bold></td><td align="left">tree, translate</td><td align="left">Rooted or unrooted trees in Newick format, with optional names and weights for each tree</td></tr><tr><td align="left"><bold>ASSUMPTIONS</bold></td><td align="left">options, usertype, wtset</td><td align="left">Constraints on allowed changes; transition cost model; weights for characters</td></tr><tr><td align="left"><bold>CODONS</bold></td><td align="left">codonposset, geneticcode</td><td align="left">Description of a reading frame and the genetic code used to translate it</td></tr><tr><td align="left"><bold>SETS</bold></td><td align="left">charset, taxset, treeset</td><td align="left">Named sets of OTUs (taxsets), trees, characters, states, or state transitions (changesets)</td></tr><tr><td align="left"><bold>NOTES</bold></td><td align="left">text, picture</td><td align="left">Annotations attaching text or pictures to sets of objects including OTUs, characters or trees</td></tr><tr><td align="left"><bold>DISTANCES</bold></td><td align="left">dimensions, format, matrix</td><td align="left">Distance matrices</td></tr><tr><td align="left"><bold>UNALIGNED</bold></td><td align="left">dimensions, format, matrix</td><td align="left">Unaligned data</td></tr><tr><td align="left"><bold>DATA</bold><sup>1</sup></td><td align="left">(see CHARACTERS)</td><td align="left">OTU labels and character data (deprecated)</td></tr></tbody></table><table-wrap-foot><p><sup>1 </sup>The DATA block format, though commonly used, is deprecated so as to encourage use of a separately declared list of OTUs in a TAXA block.</p></table-wrap-foot></table-wrap><p>Within a block, information is organized into commands and their arguments, where arguments may either be data or subcommands that refine the scope of the command. For example, a CHARACTERS block could contain the three command-argument pairs shown below, each ending with a semi-colon:</p><p>BEGIN CHARACTERS;</p><p>&#x000a0;&#x000a0;&#x000a0;DIMENSIONS nchar=12;</p><p>&#x000a0;&#x000a0;&#x000a0;FORMAT datatype=protein gap=-;</p><p>&#x000a0;&#x000a0;&#x000a0;MATRIX</p><p>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;Taxon1 ISPTCAP--RSV</p><p>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;Taxon2 EAPKCAPGVGLV</p><p>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;Taxon3 EAPKCAPGV-LV</p><p>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;Taxon4 QKPRCPPGVSLV ;</p><p>END;</p><p>A NEXUS file seems well suited for use as both input and output for the analysis of a single coherent data set with an evolutionary history. For example, it would be appropriate to use a single NEXUS file to store all of the data associated with a set of tubulin genes that are to be analyzed together in a family-wide analysis, including sequences, species source, expression data, activity data, and so on. However, if one is studying both the tubulin gene family and the actin gene family, two NEXUS files are appropriate.</p><p>The original NEXUS standard provides for extensibility via "private" application-specific blocks. This idea, as successfully used in programs such as PAUP* [<xref ref-type="bibr" rid="B6">6</xref>], is that all of the commands necessary for batch processing of a file can be added to the file itself in a private application-specific block (in the case of PAUP*, there is a "PAUP" block with commands that only PAUP can understand).</p></sec><sec><title>Benefits of an open-source Perl interface to NEXUS</title><p>The NEXUS file format is used by several programs or packages that molecular evolutionists find useful, including Mesquite [<xref ref-type="bibr" rid="B5">5</xref>], MrBayes [<xref ref-type="bibr" rid="B7">7</xref>], and HyPhy [<xref ref-type="bibr" rid="B8">8</xref>]. As evolutionary analysis becomes increasingly common in bioinformatics workflows, the need will grow for formats such as NEXUS that store data and trees together.</p><p>More importantly, the scope of evolutionary analysis &#x02013; not merely the number of users &#x02013; continues to expand. That is, while the mainstays of evolutionary analysis in the past were molecular sequence characters and discrete morphological characters, in recent years evolutionary methods have been applied to the analysis of data on genomic gene content [<xref ref-type="bibr" rid="B9">9</xref>], gene expression [<xref ref-type="bibr" rid="B10">10</xref>], and even "function", both at the level of a whole gene (or protein) [<xref ref-type="bibr" rid="B2">2</xref>] and at the level of individual sites within a protein [<xref ref-type="bibr" rid="B3">3</xref>]. Thus, it is significant that the NEXUS file implements (implicitly) a very flexible entity-attribute-value model (the character-state data model), which means that it can be applied to diverse types of data.</p><p>Existing software that uses NEXUS is mostly embedded in applications code such as PAUP* [<xref ref-type="bibr" rid="B6">6</xref>]. Some exceptions are the NEXUS methods provided by open-source toolkits such as BioPerl [<xref ref-type="bibr" rid="B11">11</xref>], and by NCL [<xref ref-type="bibr" rid="B12">12</xref>], for "NEXUS Class Library", a special purpose library written in C++. Most such implementations provide limited coverage of the NEXUS standard, and focus only on input and output of files, without providing a toolbox of methods. More complete implementations of NEXUS that provide a richer set of functions are needed, as in the Java source code included with Mesquite [<xref ref-type="bibr" rid="B5">5</xref>]. A Perl implementation would be valuable due to the popularity of Perl with biological programmers, who value its ease of use.</p></sec></sec><sec><title>Implementation</title><sec><title>Object-oriented Perl practices</title><p>Bio::NEXUS is written as a set of object-oriented (OO) Perl modules. An OO interface is ideal for two major reasons. First, NEXUS files are syntactically and organizationally complex, and OO Perl provides an easy-to-use abstraction. Users, for example, can rename taxa throughout a NEXUS file by using the <italic>rename_otus </italic>method and providing a map of old names to new names, without worrying about the details of how that object is structured or where the names are stored. By allowing Bio::NEXUS to handle the file formatting, users can focus on manipulating and interpreting data. Second, An OO implementation is also useful when data can be organized hierarchically. For example, a Bio::NEXUS::Tree (a phylogeny) is part of a Bio::NEXUS::TreesBlock, which is a Bio::NEXUS::Block, which is part of a Bio::NEXUS object. In this way, all block types can inherit generic functions (methods) from the Bio::NEXUS::Block class. The OO structure also means that a Bio::NEXUS object "knows" what it comprises, so that when a method is called (such as to remove some OTUs), the API automatically calls all the necessary methods at lower hierarchical levels (such as removing the OTUs from the character matrices, the trees, and so on).</p><p>The Bio::NEXUS API contains 22 modules in 22 files, organized in a way that reflects the structure of Bio::NEXUS objects: within the "Bio" directory (at the top level of the library) are the NEXUS base package and a directory called "NEXUS", which in turn contains the remaining 21 packages that define parts of the NEXUS class. In most cases, these 21 packages represent different block types, although there are some exceptions, e.g. there are separate tree and node classes that allow tree methods to be separated from the complexities of NEXUS files.</p><p>The 22 Bio::NEXUS modules define 351 methods, of which 250 are public methods, meaning they provide the API. The modules contain 4229 lines of code, 2706 lines of POD (Plain Old Documentation), and 391 lines of embedded comments for a total of 7326 non-whitespace lines.</p></sec><sec><title>NEXUS parsing and the NEXUS standard</title><p>NEXUS files may be thought of as a series of commands, where each command ends with a semicolon:</p><p>&#x0003c;command_word&#x0003e; [&#x0003c;subcommand&#x0003e;] [&#x0003c;arguments&#x0003e;];</p><p>The one exception is that NEXUS files must begin with the string '#NEXUS', without quotation. NEXUS commands may be as simple as 'END;', which is used to indicate the end of a block, or as complex as the MATRIX command, which can take an entire multiple sequence alignment as its argument list. The Bio::NEXUS parser reads in an entire NEXUS file and breaks it into tokens, thereby making whitespace unimportant except as a delimiter. Spaces, tabs, and newlines are treated equivalently as delimiters, and multiple consecutive whitespace characters are treated as one. It is therefore possible for an entire NEXUS file, including a multiple sequence alignment and tree, to be on one line. The rare exception is that users who wish to store an interleaved multiple sequence alignment must use newlines to denote the end of each alignment row.</p><p>Interpreting the NEXUS file format requires a sophisticated, context-sensitive parser. In the NEXUS standard, a token is defined as a word (an unbroken sequence of non-punctuation, non-whitespace characters) or a single punctuation character (()[]{} /\, ; : = * ' &#x0201d; ' + - &#x0003c; &#x0003e;). Single or double quotation marks, however, cause the enclosed to be treated as a single 'word', such as 'Human (alpha tubulin) [20&#x02013;94]'. The underscore is taken to be synonymous with a single space; therefore, 'Human alpha tubulin' and Human_alpha_tubulin are indistinguishable to the Bio::NEXUS parser, although the latter format is always used for output.</p><p>When not quoted, square brackets denote comments, therefore, the string</p><p>&#x000a0;&#x000a0;&#x000a0;Human (alpha tubulin) [20&#x02013;94]</p><p>if unquoted, would be interpreted as three words and one comment. Comments may be nested, as in [this [example]], in which case all square brackets must be paired, although nested comments have no special meaning per se. Bio::NEXUS attempts to keep track of the location of comments and reassociate them with the correct block when writing output. However, as Bio::NEXUS can be used to add, remove, and alter blocks or commands, it may be impossible to place a comment adjacent to its original command or block. For this reason (and others), comments should not be used as an <italic>ad hoc </italic>method of storing data.</p><p>The NEXUS format often is extended by application-specific or "private" blocks as allowed in the original format description [<xref ref-type="bibr" rid="B4">4</xref>]. If the Bio::NEXUS parser encounters an unfamiliar block type (e.g., a private block generated by MrBayes or PAUP*), an UnknownBlock object is created that stores (verbatim) the content of the unfamiliar block; this content is then included appropriately in the output stream whenever the Bio::NEXUS object is written out.</p><p>If the parser encounters an unfamiliar command (within a familiar type of block), however, an error results. This behavior is desirable for two reasons. First, unfamiliar commands often represent syntax errors or misspellings. Second, commands may be used to change how data are interpreted, thus ignoring an unfamiliar command without throwing an error could mislead users to assume that the data have been interpreted correctly.</p></sec><sec><title>Structure of Bio::NEXUS objects</title><p>The structure of Bio::NEXUS objects reflects the organization of the NEXUS file format, as well as the implicit data models used in bioinformatics. For this reason, some information is stored literally, such as the order of blocks in a file or the taxa listed in a TaxaBlock, while some information is interpreted, such as the New Hampshire (a.k.a., Newick) tree string in a TreesBlock. The handling and placement of comments in NEXUS files is defined ambiguously by the standard. Bio::NEXUS keeps track of comment order and position relative to blocks, rather than relative to commands or the data they may contain. The exception is the case of tree strings, where square-bracketed strings are used to store node-associated data (by convention, branch-support or bootstrap values are stored as square-bracketed strings after nodes in a tree string; the NHX standard [<xref ref-type="bibr" rid="B13">13</xref>] described in the Discussion takes this convention further, allowing various types of data to be stored within square-bracketed strings within the tree string).</p><p>At the topmost level, a Bio::NEXUS object comprises an ordered list of block objects and block-level comments (comments found outside of blocks). Block objects may contain comments, simple attributes (e.g. alignment length and gap character in a CharacterBlock object), and objects (e.g. a Tree object within a TreesBlock object). Objects are used for data with complex structure or when data may require complex manipulations. Both are true of trees.</p><p>The organization of the Bio::NEXUS object is based on specific data models. A set of data is defined by a list of OTUs ("taxa" in the NEXUS language), or unique identifiers, provided in a TaxaBlock object. All other data provide either relationships between OTUs (e.g. trees, taxsets specifying sets of OTUs), or attributes of specific OTUs (e.g. protein sequences, intron positions). Some components of Bio::NEXUS objects are also based on specific data models. For example, Tree objects implicitly represent directed acyclic graphs, and therefore are represented by a hierarchy of Node objects with parent-child relationships. CharactersBlock objects are based on the character-state data model already described: each taxon ("entity") is stored as a TaxUnit object that has an associated sequence, or one state ("value") for each character ("attribute"). Characters that are polymorphic (denoted in a NEXUS file using parentheses, e.g. "TCA(AG)C") or unresolved (denoted using curly braces) may have multiple states for each character. If a frequency distribution is known for characters with multiple states, that is also stored.</p></sec></sec><sec><title>Results</title><sec><title>Examples of utility code: re-naming, re-rooting, and format conversion</title><p>Bio::NEXUS facilitates rapid development of utility scripts and "glue code" for typical bioinformatics tasks such as creating formatted files, manipulating data in files, converting formats, and developing wrappers. Below we provide several examples based on the file "example.nex" (see Additional file <xref ref-type="supplementary-material" rid="S2">2</xref>), which consists of the following text:</p><p>#NEXUS</p><p>BEGIN TAXA;</p><p>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;DIMENSIONS ntax=4;</p><p>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;TAXLABELS A B C D;</p><p>END;</p><p>BEGIN CHARACTERS;</p><p>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;DIMENSIONS nchar=25;</p><p>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;FORMAT DATATYPE=protein;</p><p>MATRIX</p><p>&#x000a0;&#x000a0;&#x000a0;A IKKGANLFKTRCAQCHTVEKDGGNI</p><p>&#x000a0;&#x000a0;&#x000a0;B LKKGEKLFTTRCAQCHTLKEGEGNL</p><p>&#x000a0;&#x000a0;&#x000a0;C STKGAKLFETRCKQCHTVENGGGHV</p><p>&#x000a0;&#x000a0;&#x000a0;D LTKGAKLFTTRCAQCHTLEGDGGNI</p><p>;</p><p>END;</p><p>BEGIN TREES;</p><p>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;TREE my_tree = (((A:2,B:3):1,C:1):1,D:1)root;</p><p>END;</p><p>In the course of carrying out a scientific analysis, researchers will often wish to carry out complex operations that edit, transform or otherwise manipulate data stored in a file. While such steps often can be done "by hand" using a text editor, software tools reduce errors and allow automation. Bio::NEXUS facilitates developing glue code for these operations because, in addition to providing mutators and accessors for the elements of NEXUS objects, it also provides higher-level methods that perform a composite of operations or that carry out a non-trivial manipulation of data.</p><p>Re-rooting a tree is a common manipulation that typically is far too complex to carry out by editing a tree string directly with a text editor. In the example of re-rooting shown below, a Bio::NEXUS object is constructed, the manipulation is performed, and the altered object is written out to a new file.</p><p>use Bio::NEXUS;</p><p>my $nexus_obj = new Bio::NEXUS('example.nex');</p><p>$nexus_obj = $nexus_obj-&#x0003e;reroot('A');</p><p>$nexus_obj-&#x0003e;write('rerooted.nex');</p><p>Datasets can contain multiple trees, in which case this procedure would affect the default tree, unless a different tree is specified by name (in the NEXUS standard, each tree can have a name).</p><p>In the example of naming below, a Bio::NEXUS object is constructed, and a translation hash is defined. Single letter names are replaced with more meaningful names by calling the rename_otus method. Finally, the object is written out to a new file.</p><p>use Bio::NEXUS;</p><p>my $nexus_obj = new Bio::NEXUS('example.nex');</p><p>my %translate = ('A' =&#x0003e; 'Xenopus laevis', 'B' =&#x0003e; 'Mus musculus', 'C' =&#x0003e; 'Pan paniscus', 'D' =&#x0003e; 'Homo sapiens');</p><p>$nexus_obj-&#x0003e;rename_otus(%translate);</p><p>$nexus_obj-&#x0003e;write('renamed.nex');</p><p>Format conversion is a common problem in bioinformatics. Formats commonly encountered in evolutionary bioinformatics include PHYLIP, FASTA, MEGA, GCG (PileUp), and ClustalW. Although Bio::NEXUS does not does not include high-level methods that directly parse or output formats other than NEXUS, it simplifies format conversion considerably given that NEXUS is the most complex format commonly encountered. For instance, in the example below, the protein sequence alignment from example.nex is extracted and written out in FASTA format:</p><p>use Bio::NEXUS;</p><p>$nexus_obj = new Bio::NEXUS('example.nex');</p><p>$char_block = $nexus_obj-&#x0003e;get_block('characters');</p><p>open(FASTA, '&#x0003e; example.fasta');</p><p>foreach $otu (@{ $char_block-&#x0003e;get_otus()}){</p><p>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;print FASTA "&#x0003e;", $otu-&#x0003e;get_name(), "\n";</p><p>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;print FASTA @{$otu-&#x0003e;get_seq()},"\n";</p><p>}</p><p>In the example below of converting to the format used by the PHYLIP [<xref ref-type="bibr" rid="B14">14</xref>] package, an additional line of code is required to get and print the number of taxa (OTUs) along with the length of the alignment (using get_ntax and get_nchar). Also, inside the foreach loop that prints the alignment itself, a more complex print command is used to ensure that OTU names occupy no more than ten characters, as per the PHYLIP [<xref ref-type="bibr" rid="B14">14</xref>] standard (the new names become Pan_panisc, Xenopus_la, Homo_sapie and Mus_muscul).</p><p>use Bio::NEXUS;</p><p>$nexus_obj = new Bio::NEXUS('example.nex');</p><p>$char_block = $nexus_obj-&#x0003e;get_block('characters');</p><p>open(PHYLIP, '&#x0003e; infile'); # "infile" is the filename PHYLIP requires</p><p>print PHYLIP $char_block-&#x0003e;get_ntax(). ' ' . $char_block-&#x0003e;get_nchar() . "\n";</p><p>foreach my $otu (@{ $char_block-&#x0003e;get_otus() }) {</p><p>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;printf PHYLIP "%-10.10s ", $otu-&#x0003e;get_name();</p><p>&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;&#x000a0;print PHYLIP @{$otu-&#x0003e;get_seq,()}, "\n";</p><p>}</p><p>By calling additional methods, more complex scripts can be developed. For instance, the restriction on name lengths in PHYLIP files may create a problem if the truncated names are non-unique (e.g., the first 10 characters of Anolis_tubA and Anolis_tubB are the same). The problem of preserving long names while using PHYLIP programs can be solved by writing a Bio::NEXUS wrapper that uses NEXUS as its input and output format: internally the wrapper would use rename_otus to convert OTU names to a temporary set of short identifiers (e.g., otu_1, otu_2, . . .), interface with the PHYLIP package, add the PHYLIP-generated results to the NEXUS object, then use rename_otus again to convert back to the original names before writing out the modified object to a new NEXUS file.</p></sec><sec><title>Example of a stand-alone tool: nextool.pl</title><p>From the lack of available software tools and the high frequency of non-compliant files in the user community, it is apparent that NEXUS users typically manage and edit their data files manually using a text editor. However, this is not practical for larger data sets and for large numbers of files. For instance, to re-root a tree by manipulating the tree string directly with a text editor is a daunting task that invites human errors. Safe removal of an OTU is equally daunting as it is not merely a matter of searching for the OTU label and deleting it along with any associated data. As the NEXUS standard allows taxa to be referenced by a number representing the order in which they were declared, the data for an OTU are not always associated syntactically with the OTU label; for the same reason, removing an OTU changes the system of referencing for all subsequent OTUs. Furthermore, if the OTU is the first shown in a character matrix, then--following a convention widely used with sequence alignments &#x02013; its character states may be used as a reference states such that, for other OTUs listed below it, only differences are shown (with similarities indicated typically by the "matchchar" symbol, typically a "."). In such cases, deleting the OTU is not possible without semantic processing and rewriting of the character matrix.</p><p>Indeed, the burden imposed by the complexity of the NEXUS format coupled with the lack of suitable editing tools may be one reason for the under-utilization of NEXUS files.</p><p>To address this problem, we have developed nextool.pl, a script that automates various tasks typically involved in managing, curating and editing data sets in NEXUS format. The nextool.pl script is found in the exec/directory of the Bio::NEXUS package, and is typically installed in the user's executable path during an automated installation. It operates as a command editor with the syntax:</p><p>nextool.pl &#x0003c;input_file&#x0003e; [&#x0003c;output_file&#x0003e;] [&#x0003c;command&#x0003e; [&#x0003c;arguments&#x0003e;]]</p><p>That is, an output file is generated by carrying out some command on the contents of the input file. Useful commands include <bold>rewrite </bold>(to rewrite a file in standard format), <bold>rename_otus </bold>(using, as a command argument, a string that maps old names to new ones, or the name of a file with such a mapping), <bold>reroot </bold>(to reroot a tree on a named node or OTU), <bold>select</bold>, <bold>exclude </bold>and <bold>makesets</bold>. The <bold>select </bold>and <bold>exclude </bold>commands may operate on blocks, columns (characters), trees, subtrees or OTUs. For instance, the command</p><p>nextool.pl. infile outfile select columns "1&#x02013;3, 8, 10&#x02013;45"</p><p>creates an output file "outfile" with only columns (characters) 1&#x02013;3, 8, and 10&#x02013;45 selected from the input file "infile". The command</p><p>nextool.pl infile outfile makesets bycharstate "isotype A"="124 H"</p><p>would add an OTU set named "isotype A" including only those OTUs that have the character state "H" for character number 124. This named set then could be referenced in subsequent operations such as <bold>select </bold>or <bold>exclude</bold>. Sets can also be referenced in set operations, so that (for instance), we could define a set consisting of all OTUs that have "H" for character 124 but do not have "E" for character 271.</p></sec><sec><title>Example of a web-based application: Nexplorer</title><p>Bio::NEXUS plays a key role in Nexplorer, a web-based program for interactive browsing and manipulation of character state data and trees [<xref ref-type="bibr" rid="B15">15</xref>]. Nexplorer has a 3-tiered design: the front end consists of JavaScript, HTML and images, the back end consists of NEXUS files along with a database of taxonomic information, and the middle layer consists of CGI and Bio::NEXUS, which is used to access and manipulate the data in NEXUS files. To generate custom views of data or to create subsets of data for further analysis, users need only to upload a properly formatted NEXUS file to Nexplorer. The server responds by generating an image of the data and by mapping such things as JavaScript pop-up menus to the nodes of tree that allow the user to re-root a tree, exclude or select a subtree, and so on.</p></sec></sec><sec><title>Discussion and conclusion</title><sec><title>Comparison with other implementations</title><p>As Lewis [<xref ref-type="bibr" rid="B12">12</xref>] suggests, developing a library to support NEXUS fully is difficult due to the flexibility built into the standard. According to Maddison et al. [<xref ref-type="bibr" rid="B4">4</xref>] writing in 1997, "no program can understand more than about 60% of the elements described" by the standard.</p><p>To measure the degree of implementation precisely, we have used the Backus-Naur formalization of NEXUS provided by Iglesias, et al. [<xref ref-type="bibr" rid="B16">16</xref>] to generate a list of keywords. The keywords are reserved tokens representing commands and subcommands (or command modifiers), some of them (e.g., "interleave") used in several different blocks. The total number of keyword-block combinations is 119. Currently Bio::NEXUS provides some support for 80% (8 of 10) of the block types (all but NOTES and CODONS) and 68% (81/119) of the keyword-block combinations. The latter number is reflected in the current version number (0.68) of the Bio::NEXUS release.</p><p>Other currently available software libraries to support NEXUS include NCL [<xref ref-type="bibr" rid="B12">12</xref>] and the code available in various Bio* toolkits [<xref ref-type="bibr" rid="B17">17</xref>]. According to the documentation, NCL implements TAXA, TREES and DISTANCES completely, and implements CHARACTERS and ASSUMPTIONS partially. Other implementations typically focus on TAXA and TREES block, and support common uses of CHARACTERS blocks without implementing various format options. Bio::Phylo by Rutger Vos [<xref ref-type="bibr" rid="B18">18</xref>] focuses on TAXA, TREES and CHARACTERS. BioPerl supports TAXA, TREES, and CHARACTERS blocks, but writes data only in the deprecated DATA block format. The BioJava NEXUS parser handles DATA, CHARACTERS, DISTANCES, TREES, and TAXA blocks. The Mesquite project [<xref ref-type="bibr" rid="B5">5</xref>], also in Java, provides a documented NEXUS API with support for all standard blocks except UNALIGNED.</p></sec><sec><title>Extensions to the NEXUS standard</title><p>Bio::NEXUS implements a few extensions to the NEXUS standard. One of these is the convention used in Mesquite project files of allowing multiple blocks of the same type, with linking-by-name between blocks. The <bold>title </bold>command is used to assign a name to a block, and the <bold>link </bold>command is used to refer to another block by its title, e.g., a TREES block with trees inferred from the data in a CHARACTERS block entitled "gene data" could have the command</p><p>&#x000a0;&#x000a0;&#x000a0;link characters = "gene data";</p><p>Bio::NEXUS also implements the NHX (New Hampshire Extended) standard of Zmasek and Eddy [<xref ref-type="bibr" rid="B13">13</xref>]. NHX expands the original "Newick" or "New Hampshire" standard, wherein the clades of a phylogeny are represented by pairs of nested parentheses (see the examples in Results above). NHX tree strings incorporate special NEXUS comments that contain tags specifying additional information about nodes of a tree. The syntax of an NHX comment is [&#x00026;&#x00026;NHX:&#x0003c;tag&#x0003e;=&#x0003c;value&#x0003e;], the comment follows the node, and each tag is responsible for carrying specific information about the given node. For example, the "B" tag refers to the branch support (e.g., bootstrap) value at the given node, and "T" tag refers to the NCBI taxonomy ID. The Bio::NEXUS::NHXCmd module provides the support for reading, manipulation, and writing of the NHX comments. Methods in the Bio::NEXUS::Node class provide the capacity to add, remove, and edit specific NHX tags and the corresponding values.</p></sec><sec><title>Future challenges for NEXUS, Bio::NEXUS and evolutionary informatics</title><p>NEXUS files have been in use for many years. Users and developers presumably choose NEXUS because it is the preferred or required input file for valuable programs (e.g., PAUP*), because of the capacity to store trees with data, and because of the expressivity that allows diverse kinds of data to be represented along with constraints or assumptions. As integrative and evolutionary approaches to biological analysis become more common, there will be a growing need for formats that provide the functionality of NEXUS.</p><p>Yet serious problems have emerged from the complexity of the standard and the historical lack of software support. First, the standard is so complex that users and developers commonly misunderstand it (a substantial fraction of NEXUS files in current use violate the standard; several software applications generate or expect poorly formed or deprecated file formats). Because there is no generalized NEXUS editor, users apparently hand-edit their files using text editors or word processors, leading to typographic errors and to poorly formed files. Second, the standard is so extensive, with so many options and so many variations in syntax, that no developer has attempted a complete implementation, except for the developers of a Prolog-based parser [<xref ref-type="bibr" rid="B16">16</xref>]. Indeed, some applications support only the deprecated DATA block format. Finally, the NEXUS grammar is more like that of a natural language and cannot be parsed using conventional scanning-parsing routines, due to the inability to resolve ambiguous tokens prior to extensive semantic processing [<xref ref-type="bibr" rid="B16">16</xref>]. The next-generation standard to replace NEXUS should be defined in a formal language, and it should i) be more easily parsed; ii) make use of available technology that facilitates crucial tasks such as validation and editing (e.g., as for an XML-based standard such as PhyloXML [<xref ref-type="bibr" rid="B19">19</xref>]); iii) import ontologies for character data (e.g., nucleotide or amino acid states); and perhaps iv) utilize a process-specification language to describe steps in an analysis (both previous steps and subsequent ones to be carried out).</p><p>Nevertheless, as there is no replacement currently on the horizon, it seems clear that NEXUS files will continue to be used for years to come. A robust and easy-to-use API such as Bio::NEXUS will make it easier to manage NEXUS files, to maintain legacy data and convert it to other forms, and&#x02013; when combined with greater community attention to standards for integrative analyses &#x02013; will facilitate the transition to future technologies to achieve integration. Future plans for Bio::NEXUS, intended to facilitate the ongoing use of NEXUS and to protect legacy data, include offering 100 % support for the standard and common extensions, validation capacity, and object integration with BioPerl [<xref ref-type="bibr" rid="B11">11</xref>].</p></sec></sec><sec><title>Availability and requirements</title><p>Bio::NEXUS requires Perl 5.x, available for free download from CPAN [<xref ref-type="bibr" rid="B20">20</xref>]. The current release of Bio::NEXUS is available as an installable package from CPAN [<xref ref-type="bibr" rid="B20">20</xref>]; the current development version of the source code is available from SourceForge [<xref ref-type="bibr" rid="B21">21</xref>]. The CPAN package includes Perl code, test files, documentation, some useful scripts (e.g., nextool.pl), and examples. On UNIX-like systems (Mac OS X, Linux, UNIX, or Cygwin running within Windows) Bio::NEXUS can be installed using "perl -MCPAN -e 'install Bio::NEXUS"'; or on Windows systems using ppm (Perl Package Manager). The test suite (implemented with Perl's "Test" module) comprises over 30 test scripts implementing over 460 subtests. The documentation, written in POD (Plain Old Documentation) format, includes a user manual and a tutorial (see below for examples). The code files also are annotated with POD, hence references for Bio::NEXUS modules and their methods can be generated on the fly using the standard perldoc command.</p></sec><sec><title>Authors' contributions</title><p>TJH helped to design and implement the code, to write the documentation, and to draft the manuscript; CL and WQ helped to design and implement early versions of the library and tools; PY and VG carried out testing and aided in implementation; AS participated in design, implementation and testing, helped to draft the manuscript, and oversaw all aspects of the project; all authors read and approved the manuscript.</p></sec><sec sec-type="supplementary-material"><title>Supplementary Material</title><supplementary-material content-type="local-data" id="S1"><caption><title>Additional file 1</title><p>figure1.nex. The NEXUS file corresponding to Figure 1.</p></caption><media xlink:href="1471-2105-8-191-S1.nex" mimetype="text" mime-subtype="plain"><caption><p>Click here for file</p></caption></media></supplementary-material><supplementary-material content-type="local-data" id="S2"><caption><title>Additional file 2</title><p>example.nex. A simple NEXUS file used in the tutorial examples.</p></caption><media xlink:href="1471-2105-8-191-S2.nex" mimetype="text" mime-subtype="plain"><caption><p>Click here for file</p></caption></media></supplementary-material></sec></body><back><ack><sec><title>Acknowledgements</title><p>The authors thank John Bradley, Mark Holder, Aaron Mackey, Eugene Melamud, and Paul Lewis for suggestions and bug reports, and Mikhail Bezruchko for his his work on the test suite. This work was supported by the Computational Biology Program of the National Library of Medicine (NIH grant R01-LM07218 to A.S), the Biological Sciences Department of Hunter College, the Howard Hughes Medical Institute Undergraduate Science Education Program in Biology, and a Research Centers in Minority Institutions award (NIH RR03037 to W.Q.). The identification of specific commercial software products in this paper is for the purpose of specifying a protocol, and does not imply a recommendation or endorsement by the National Institute of Standards and Technology.</p></sec></ack><ref-list><ref id="B1"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Harvey</surname><given-names>PH</given-names></name><name><surname>Pagel</surname><given-names>MD</given-names></name></person-group><article-title>The Comparative Method in Evolutionary Biology</article-title><source>Oxford Series in Ecology and Evolution</source><year>1991</year><publisher-name>Oxford , Oxford University Press</publisher-name><fpage>285</fpage></citation></ref><ref id="B2"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Eisen</surname><given-names>JA</given-names></name></person-group><article-title>Phylogenomics: improving functional predictions for uncharacterized genes by evolutionary analysis</article-title><source>Genome Res</source><year>1998</year><volume>8</volume><fpage>163</fpage><lpage>167</lpage><pub-id pub-id-type="pmid">9521918</pub-id></citation></ref><ref id="B3"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Gaucher</surname><given-names>EA</given-names></name><name><surname>Gu</surname><given-names>X</given-names></name><name><surname>Miyamoto</surname><given-names>MM</given-names></name><name><surname>Benner</surname><given-names>SA</given-names></name></person-group><article-title>Predicting functional divergence in protein evolution by site-specific rate shifts</article-title><source>Trends Biochem Sci</source><year>2002</year><volume>27</volume><fpage>315</fpage><lpage>321</lpage><pub-id pub-id-type="pmid">12069792</pub-id><pub-id pub-id-type="doi">10.1016/S0968-0004(02)02094-7</pub-id></citation></ref><ref id="B4"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Maddison</surname><given-names>DR</given-names></name><name><surname>Swofford</surname><given-names>DL</given-names></name><name><surname>Maddison</surname><given-names>WP</given-names></name></person-group><article-title>NEXUS: an extendible file format for systematic information</article-title><source>Systematic Biology</source><year>1997</year><volume>46</volume><fpage>590</fpage><lpage>621</lpage><pub-id pub-id-type="pmid">11975335</pub-id><pub-id pub-id-type="doi">10.2307/2413497</pub-id></citation></ref><ref id="B5"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Maddison</surname><given-names>W</given-names></name><name><surname>Maddison</surname><given-names>D</given-names></name></person-group><source>Mesquite: A modular Programming System for Evolutionary Analysis</source><year>2000</year><edition>NA</edition><publisher-name>http://spiders.arizona.edu/mesquite , University of Arizona</publisher-name><ext-link ext-link-type="uri" xlink:href="http://spiders.arizona.edu/mesquite"/></citation></ref><ref id="B6"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Swofford</surname><given-names>DL</given-names></name></person-group><source>PAUP*.  Phylogenetic Analysis Using Parsimony (*and Other Methods).</source><year>1999</year><edition>4</edition><publisher-name>Sunderland, Mass. , Sinauer Associates</publisher-name><ext-link ext-link-type="uri" xlink:href="http://www.lms.si.edu/PAUP"/></citation></ref><ref id="B7"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Huelsenbeck</surname><given-names>JP</given-names></name><name><surname>Ronquist</surname><given-names>F</given-names></name></person-group><article-title>MRBAYES: Bayesian inference of phylogenetic trees</article-title><source>Bioinformatics</source><year>2001</year><volume>17</volume><fpage>754</fpage><lpage>755</lpage><pub-id pub-id-type="pmid">11524383</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/17.8.754</pub-id></citation></ref><ref id="B8"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Kosakovsky Pond</surname><given-names>SL</given-names></name><name><surname>Frost</surname><given-names>SD</given-names></name><name><surname>Muse</surname><given-names>SV</given-names></name></person-group><article-title>HyPhy: hypothesis testing using phylogenies</article-title><source>Bioinformatics</source><year>2005</year><volume>21</volume><fpage>676</fpage><lpage>679</lpage><pub-id pub-id-type="pmid">15509596</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/bti079</pub-id></citation></ref><ref id="B9"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Gu</surname><given-names>X</given-names></name><name><surname>Huang</surname><given-names>W</given-names></name><name><surname>Xu</surname><given-names>D</given-names></name><name><surname>Zhang</surname><given-names>H</given-names></name></person-group><article-title>GeneContent: software for whole-genome phylogenetic analysis</article-title><source>Bioinformatics</source><year>2005</year><volume>21</volume><fpage>1713</fpage><lpage>1714</lpage><pub-id pub-id-type="pmid">15598840</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/bti208</pub-id></citation></ref><ref id="B10"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Oakley</surname><given-names>TH</given-names></name><name><surname>Gu</surname><given-names>Z</given-names></name><name><surname>Abouheif</surname><given-names>E</given-names></name><name><surname>Patel</surname><given-names>NH</given-names></name><name><surname>Li</surname><given-names>WH</given-names></name></person-group><article-title>Comparative methods for the analysis of gene-expression evolution: an example using yeast functional genomic data</article-title><source>Mol Biol Evol</source><year>2005</year><volume>22</volume><fpage>40</fpage><lpage>50</lpage><pub-id pub-id-type="pmid">15356281</pub-id><pub-id pub-id-type="doi">10.1093/molbev/msh257</pub-id></citation></ref><ref id="B11"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Stajich</surname><given-names>JE</given-names></name><name><surname>Block</surname><given-names>D</given-names></name><name><surname>Boulez</surname><given-names>K</given-names></name><name><surname>Brenner</surname><given-names>SE</given-names></name><name><surname>Chervitz</surname><given-names>SA</given-names></name><name><surname>Dagdigian</surname><given-names>C</given-names></name><name><surname>Fuellen</surname><given-names>G</given-names></name><name><surname>Gilbert</surname><given-names>JG</given-names></name><name><surname>Korf</surname><given-names>I</given-names></name><name><surname>Lapp</surname><given-names>H</given-names></name><etal></etal></person-group><article-title>The Bioperl toolkit: Perl modules for the life sciences</article-title><source>Genome Res</source><year>2002</year><volume>12</volume><fpage>1611</fpage><lpage>1618</lpage><pub-id pub-id-type="pmid">12368254</pub-id><pub-id pub-id-type="doi">10.1101/gr.361602</pub-id></citation></ref><ref id="B12"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Lewis</surname><given-names>PO</given-names></name></person-group><article-title>NCL: a C++ class library for interpreting data files in NEXUS format</article-title><source>Bioinformatics</source><year>2003</year><volume>19</volume><fpage>2330</fpage><lpage>2331</lpage><pub-id pub-id-type="pmid">14630669</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/btg319</pub-id></citation></ref><ref id="B13"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Zmasek</surname><given-names>CM</given-names></name><name><surname>Eddy</surname><given-names>SR</given-names></name></person-group><article-title>ATV: display and manipulation of annotated phylogenetic trees</article-title><source>Bioinformatics</source><year>2001</year><volume>17</volume><fpage>383</fpage><lpage>384</lpage><pub-id pub-id-type="pmid">11301314</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/17.4.383</pub-id></citation></ref><ref id="B14"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Felsenstein</surname><given-names>J</given-names></name></person-group><source>PHYLIP (Phylogenetic inference package)</source><year>1995</year><edition>3.57</edition><publisher-name>Seattle, WA , Department of Genetics, University of Washington</publisher-name></citation></ref><ref id="B15"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Gopalan</surname><given-names>V</given-names></name><name><surname>Qiu</surname><given-names>WG</given-names></name><name><surname>Chen</surname><given-names>MZ</given-names></name><name><surname>Stoltzfus</surname><given-names>A</given-names></name></person-group><article-title>Nexplorer: phylogeny-based exploration of sequence family data</article-title><source>Bioinformatics</source><year>2006</year><volume>22</volume><fpage>120</fpage><lpage>121</lpage><pub-id pub-id-type="pmid">16267087</pub-id><pub-id pub-id-type="doi">10.1093/bioinformatics/bti747</pub-id></citation></ref><ref id="B16"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Iglesias</surname><given-names>JR</given-names></name><name><surname>Gupta</surname><given-names>G</given-names></name><name><surname>Ranjan</surname><given-names>D</given-names></name><name><surname>Pontelli</surname><given-names>E</given-names></name><name><surname>Milligan</surname><given-names>B</given-names></name></person-group><source>Logic Programming Technology for Interoperability between Bioinformatics Software Tools</source><year>2001</year><volume>Lecture Notes in Computer Science #1990</volume><publisher-name>Springer-Verlag</publisher-name><fpage>153</fpage><lpage>168</lpage></citation></ref><ref id="B17"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Mangalam</surname><given-names>H</given-names></name></person-group><article-title>The Bio* toolkits--a brief overview</article-title><source>Brief Bioinform</source><year>2002</year><volume>3</volume><fpage>296</fpage><lpage>302</lpage><pub-id pub-id-type="pmid">12230038</pub-id><pub-id pub-id-type="doi">10.1093/bib/3.3.296</pub-id></citation></ref><ref id="B18"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Vos</surname><given-names>R</given-names></name></person-group><article-title>Bio::Phylo</article-title><ext-link ext-link-type="uri" xlink:href="http://search.cpan.org/dist/Bio-Phylo/"/></citation></ref><ref id="B19"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Zmasek</surname><given-names>C</given-names></name><name><surname>Cannon</surname><given-names>E</given-names></name></person-group><article-title>phyloXML &#x02022; an XML language for phylogenies</article-title><ext-link ext-link-type="uri" xlink:href="http://www.phyloxml.org"/></citation></ref><ref id="B20"><citation citation-type="other"><article-title>Comprehensive Perl Archive Network (CPAN)</article-title><ext-link ext-link-type="uri" xlink:href="http://www.cpan.org"/></citation></ref><ref id="B21"><citation citation-type="other"><article-title>SourceForge</article-title><ext-link ext-link-type="uri" xlink:href="http://sourceforge.net"/></citation></ref></ref-list></back></article>


