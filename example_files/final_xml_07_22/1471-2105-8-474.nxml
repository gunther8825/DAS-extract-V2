<!DOCTYPE article PUBLIC "-//NLM//DTD Journal Archiving and Interchange DTD v2.3 20070202//EN" "archivearticle.dtd">
<article xmlns:xlink="http://www.w3.org/1999/xlink" article-type="product-review"><?properties open_access?><front><journal-meta><journal-id journal-id-type="nlm-ta">BMC Bioinformatics</journal-id><journal-title>BMC Bioinformatics</journal-title><issn pub-type="epub">1471-2105</issn><publisher><publisher-name>BioMed Central</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmid">18070356</article-id><article-id pub-id-type="pmc">2222658</article-id><article-id pub-id-type="publisher-id">1471-2105-8-474</article-id><article-id pub-id-type="doi">10.1186/1471-2105-8-474</article-id><article-categories><subj-group subj-group-type="heading"><subject>Software</subject></subj-group></article-categories><title-group><article-title>High-throughput sequence alignment using Graphics Processing Units</article-title></title-group><contrib-group><contrib id="A1" equal-contrib="yes" corresp="yes" contrib-type="author"><name><surname>Schatz</surname><given-names>Michael C</given-names></name><xref ref-type="aff" rid="I1">1</xref><xref ref-type="aff" rid="I2">2</xref><email>mschatz@umiacs.umd.edu</email></contrib><contrib id="A2" equal-contrib="yes" contrib-type="author"><name><surname>Trapnell</surname><given-names>Cole</given-names></name><xref ref-type="aff" rid="I1">1</xref><xref ref-type="aff" rid="I2">2</xref><email>cole@cs.umd.edu</email></contrib><contrib id="A3" contrib-type="author"><name><surname>Delcher</surname><given-names>Arthur L</given-names></name><xref ref-type="aff" rid="I1">1</xref><xref ref-type="aff" rid="I2">2</xref><email>adelcher@umiacs.umd.edu</email></contrib><contrib id="A4" contrib-type="author"><name><surname>Varshney</surname><given-names>Amitabh</given-names></name><xref ref-type="aff" rid="I2">2</xref><email>varshney@cs.umd.edu</email></contrib></contrib-group><aff id="I1"><label>1</label>Center for Bioinformatics and Computational Biology, University of Maryland, College Park, MD, USA</aff><aff id="I2"><label>2</label>Department of Computer Science, University of Maryland, College Park, MD, USA</aff><pub-date pub-type="collection"><year>2007</year></pub-date><pub-date pub-type="epub"><day>10</day><month>12</month><year>2007</year></pub-date><volume>8</volume><fpage>474</fpage><lpage>474</lpage><ext-link ext-link-type="uri" xlink:href="http://www.biomedcentral.com/1471-2105/8/474"/><history><date date-type="received"><day>20</day><month>8</month><year>2007</year></date><date date-type="accepted"><day>10</day><month>12</month><year>2007</year></date></history><permissions><copyright-statement>Copyright &#x000a9; 2007 Schatz et al; licensee BioMed Central Ltd.</copyright-statement><copyright-year>2007</copyright-year><copyright-holder>Schatz et al; licensee BioMed Central Ltd.</copyright-holder><license license-type="open-access" xlink:href="http://creativecommons.org/licenses/by/2.0"><p>This is an Open Access article distributed under the terms of the Creative Commons Attribution License (<ext-link ext-link-type="uri" xlink:href="http://creativecommons.org/licenses/by/2.0"/>), which permits unrestricted use, distribution, and reproduction in any medium, provided the original work is properly cited.</p><!--<rdf xmlns="http://web.resource.org/cc/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns:dc="http://purl.org/dc/elements/1.1" xmlns:dcterms="http://purl.org/dc/terms"><Work xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" rdf:about=""><license rdf:resource="http://creativecommons.org/licenses/by/2.0"/><dc:type rdf:resource="http://purl.org/dc/dcmitype/Text"/><dc:author>
               Schatz
               C
               Michael
               
               
               mschatz@umiacs.umd.edu
            </dc:author><dc:title>
            High-throughput sequence alignment using Graphics Processing Units
         </dc:title><dc:date>2007</dc:date><dcterms:bibliographicCitation>BMC Bioinformatics 8(1): 474-. (2007)</dcterms:bibliographicCitation><dc:identifier type="sici">1471-2105(2007)8:1&#x0003c;474&#x0003e;</dc:identifier><dcterms:isPartOf>urn:ISSN:1471-2105</dcterms:isPartOf><License rdf:about="http://creativecommons.org/licenses/by/2.0"><permits rdf:resource="http://web.resource.org/cc/Reproduction" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/Distribution" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Notice" xmlns=""/><requires rdf:resource="http://web.resource.org/cc/Attribution" xmlns=""/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks" xmlns=""/></License></Work></rdf>--></license></permissions><abstract><sec><title>Background</title><p>The recent availability of new, less expensive high-throughput DNA sequencing technologies has yielded a dramatic increase in the volume of sequence data that must be analyzed. These data are being generated for several purposes, including genotyping, genome resequencing, metagenomics, and <italic>de novo </italic>genome assembly projects. Sequence alignment programs such as MUMmer have proven essential for analysis of these data, but researchers will need ever faster, high-throughput alignment tools running on inexpensive hardware to keep up with new sequence technologies.</p></sec><sec><title>Results</title><p>This paper describes MUMmerGPU, an open-source high-throughput parallel pairwise local sequence alignment program that runs on commodity Graphics Processing Units (GPUs) in common workstations. MUMmerGPU uses the new Compute Unified Device Architecture (CUDA) from nVidia to align multiple query sequences against a single reference sequence stored as a suffix tree. By processing the queries in parallel on the highly parallel graphics card, MUMmerGPU achieves more than a 10-fold speedup over a serial CPU version of the sequence alignment kernel, and outperforms the exact alignment component of MUMmer on a high end CPU by 3.5-fold in total application time when aligning reads from recent sequencing projects using Solexa/Illumina, 454, and Sanger sequencing technologies.</p></sec><sec><title>Conclusion</title><p>MUMmerGPU is a low cost, ultra-fast sequence alignment program designed to handle the increasing volume of data produced by new, high-throughput sequencing technologies. MUMmerGPU demonstrates that even memory-intensive applications can run significantly faster on the relatively low-cost GPU than on the CPU.</p></sec></abstract></article-meta></front><body><sec><title>Background</title><p>Sequence alignment has a long history in genomics research and continues to be a key component in the analysis of genes and genomes. Simply stated, sequence alignment algorithms find regions in one sequence, called here the query sequence, that are similar or identical to regions in another sequence, called the reference sequence. Such regions may represent genes, conserved regulatory regions, or any of a host of other sequence features. Alignment also plays a central role in <italic>de novo </italic>and comparative genome assembly [<xref ref-type="bibr" rid="B1">1</xref>,<xref ref-type="bibr" rid="B2">2</xref>], where thousands or millions of sequencing reads are aligned to each other or to a previously sequenced reference genome. New, inexpensive large-scale sequencing technologies [<xref ref-type="bibr" rid="B3">3</xref>] can now generate enormous amounts of sequence data in a very short time, enabling researchers to attempt genome sequencing projects on a much larger scale than previously. Aligning these sequence data using current algorithms will require very high-performance computers, of the type currently available only at the largest sequencing and bioinformatics centers. Furthermore, realizing the dream of widespread personal genomics at hospitals and other clinical settings requires sequence alignment to be low cost in addition to high-throughput.</p><p>Most personal computer workstations today contain hardware for 3D graphics acceleration called Graphics Processing Units (GPUs). Recently, GPUs have been harnessed for non-graphical, general purpose (GPGPU) applications. GPUs feature hardware optimized for simultaneously performing many independent floating-point arithmetic operations for displaying 3D models and other graphics tasks. Thus, GPGPU programming has been successful primarily in the scientific computing disciplines which involve a high level of numeric computation. However, other applications could be successful, provided those applications feature significant parallelism.</p><p>In this paper, we describe a GPGPU program called MUMmerGPU that performs exact sequence alignment using suffix trees on graphics hardware. Our implementation runs on recent hardware available from nVidia using a new software development kit (SDK) for GPGPU progamming called Compute Unified Device Architecture (CUDA). MUMmerGPU is targeted to tasks in which many small queries, such as reads from a sequencing project, are aligned to a large reference sequence. To assess the performance of MUMmerGPU we compare it to the exact alignment component of MUMmer called mummer. MUMmer is a very fast and widely used application for this type of task [<xref ref-type="bibr" rid="B4">4</xref>], and is also used as the alignment engine for the comparative assembler AMOScmp [<xref ref-type="bibr" rid="B2">2</xref>]. Overall MUMmerGPU is more than three times faster than mummer on typical sequence alignment tasks involving data from three recent sequencing projects. As implemented, MUMmerGPU is a direct replacement for mummer and can be used with any other programs that process mummer output, including the other components of MUMmer that post-process the exact alignments computed by mummer into larger inexact alignments.</p><sec><title>Sequence alignment</title><p>One of the most successful algorithms for computing alignments between sequences is MUMmer [<xref ref-type="bibr" rid="B4">4</xref>-<xref ref-type="bibr" rid="B6">6</xref>]. The first stage of MUMmer is performed by a component called mummer, which computes exact alignments between the pair of sequences. These alignments can be used directly to infer large-scale sequence structure, or they can be used to seed extensions to longer inexact alignments using the post-processing tools bundled with MUMmer. Unlike other popular sequence alignment programs such as BLAST [<xref ref-type="bibr" rid="B7">7</xref>], FASTA [<xref ref-type="bibr" rid="B8">8</xref>], and LAGAN [<xref ref-type="bibr" rid="B9">9</xref>], which use fixed length seeds for constructing their alignments, mummer alignments are variable-length maximal exact matches, where maximal means that they cannot be extended on either end without introducing a mismatch. First, mummer pre-processes the reference sequence to create a data structure, called a <italic>suffix tree</italic>. This data structure allows mummer to then compute all maximal exact substring alignments of a query sequence in time proportional to the length of the query. The time to pre-process the reference sequence is proportional to its length (which may be considerable for very long sequences), but this time becomes insignificant when amortized across many query searches. Consequently, suffix trees are used in several alignment algorithms, including MGA [<xref ref-type="bibr" rid="B10">10</xref>] and REPuter [<xref ref-type="bibr" rid="B11">11</xref>]. The suffix tree [<xref ref-type="bibr" rid="B12">12</xref>] for string <italic>S </italic>is a tree that encodes every suffix of <italic>S </italic>with a unique path from the root to a leaf. For a string of length <italic>n</italic>, there are <italic>n </italic>leaf nodes for each of the <italic>n </italic>suffixes in <italic>S</italic>. Each edge in <italic>T </italic>is labeled with a substring of variable length of <italic>S </italic>called an edge-label. Concatenating edge-labels along a path from the root to a node <italic>i </italic>forms a substring, called <italic>i</italic>'s <italic>path-label </italic>in <italic>S</italic>. Leaves in the tree are labeled with the position where the path-label begins in <italic>S</italic>. Internal nodes have at least 2 children, representing positions where repeated substrings diverge. The edge-labels of the children of a node each begin with a different character from the alphabet, so there is at most one child for each letter of the reference string's alphabet. Consequently, the depth of any leaf is at most <italic>n</italic>, and there are <italic>O</italic>(<italic>n</italic>) nodes in the tree.</p><p>A suffix tree can be constructed in <italic>O</italic>(<italic>n</italic>) time and <italic>O</italic>(<italic>n</italic>) space for a string over a fixed alphabet, such as for DNA or amino acids, by using additional pointers in the tree called <italic>suffix links</italic>. The suffix link of node <italic>v </italic>with path-label <italic>x&#x003b1; </italic>points to node <italic>v' </italic>with path-label <italic>&#x003b1; </italic>where <italic>x </italic>is a single character and <italic>&#x003b1; </italic>is a substring [<xref ref-type="bibr" rid="B13">13</xref>,<xref ref-type="bibr" rid="B14">14</xref>]. Suffix links are used to navigate between equivalent nodes of consecutive suffixes without returning to the root of the tree.</p><p>All substrings of a query string <italic>Q </italic>of length <italic>m </italic>that occur in a string <italic>S </italic>can be determined in time proportional to <italic>m </italic>by navigating the suffix tree <italic>T </italic>of <italic>S </italic>to follow the characters in <italic>Q</italic>. The algorithm begins by finding the longest prefix of <italic>Q </italic>that occurs in <italic>T</italic>, descending from the root of <italic>T </italic>and following exactly aligning characters in <italic>Q </italic>for as long as possible. Assume that substring <italic>Q</italic>[1, <italic>i</italic>] is found in <italic>T </italic>along the path-label to node <italic>v</italic>, but there is no edge from <italic>v </italic>labeled with the next character in <italic>Q </italic>because <italic>Q</italic>[1, <italic>i </italic>+ 1] is not present in <italic>S</italic>. The algorithm can then report the occurrences of <italic>Q</italic>[1, <italic>i</italic>] at the positions represented by all leaves in the subtree rooted at <italic>v </italic>after checking the alignments are maximal by comparing the left flanking base of the query and reference. The algorithm then continues by finding the longest substrings for each of the <italic>m </italic>- 1 remaining start positions in <italic>Q</italic>. However, instead of navigating the tree from the root each time, the algorithm resumes aligning with <italic>Q</italic>[<italic>i </italic>+ 1] after following the suffix link from <italic>v </italic>to <italic>v' </italic>and without reprocessing previously aligned characters.</p><p>Given a user-specifed minimum length <italic>l </italic>and a query <italic>Q</italic>, suppose there is an exact alignment of length <italic>M </italic>&#x02265; <italic>l </italic>for the substring starting at position <italic>i </italic>in the query and ending at or along the edge to node <italic>N</italic>. The length of the alignment (<italic>M</italic>) is equal to the length of the path-label of the parent of node <italic>N </italic>plus the length along the edge to <italic>N</italic>. Starting from <italic>N</italic>, the algorithm follows successive parent links up the tree, subtracting the edge length of each link from the alignment length, until the alignment length is less than <italic>l </italic>as shown in Figure <xref ref-type="fig" rid="F1">1</xref>. Let <italic>R </italic>be the node with the smallest string depth greater than <italic>l </italic>on this path. For each leaf <italic>L </italic>in the subtree rooted by <italic>R</italic>, the path-label to the lowest common ancestor of <italic>N </italic>and <italic>L </italic>defines a substring starting at <italic>i </italic>in <italic>Q </italic>which occurs in both <italic>Q </italic>and <italic>S </italic>at the reference position defined by the leaf label of <italic>L</italic>. For a thorough discussion of suffix trees and their applications, see Gusfield's classic work on sequence analysis [<xref ref-type="bibr" rid="B14">14</xref>].</p><fig position="float" id="F1"><label>Figure 1</label><caption><p><bold>Aligning a query against a suffix tree</bold>. Aligning the query ATAT against the suffix tree for ATATCAT$. The path from the root to each leaf encodes a sequence that occurs in the reference at the label of that leaf. The blue path shows the extent of the alignment in the tree. The query occurs at position 1 with a alignment length of 4. For <italic>l </italic>&#x02265; 2, MUMmerGPU will print the red nodes as alignments with an alignment length equal to 2, the sequence depth of the lowest common ancestor between the red nodes and the blue node.</p></caption><graphic xlink:href="1471-2105-8-474-1"/></fig></sec><sec><title>GPGPU programming</title><p>As the GPU has become increasingly more powerful and ubiquitous, researchers have begun exploring ways to tap its power for non-graphics, or general-purpose (GPGPU) applications [<xref ref-type="bibr" rid="B15">15</xref>]. This has proven challenging for a variety of reasons. Traditionally, GPUs have been highly specialized with two distinct classes of graphics stream processors: vertex processors, which compute geometric transformations on meshes, and fragment processors, which shade and illuminate the rasterized products of the vertex processors. The GPUs are organized in a streaming, data-parallel model in which the processors execute the same instructions on multiple data streams simultaneously. Modern GPUs include several (tens to hundreds) of each type of stream processor, so both graphical and GPGPU applications are faced with parallelization challenges [<xref ref-type="bibr" rid="B16">16</xref>]. Furthermore, on-chip caches for the processing units on GPUs are very small (often limited to what is needed for texture filtering operations) compared to general purpose processors, which feature caches measured in megabytes. Thus, read and write operations can have very high latency relative to the same operations when performed by a CPU in main memory.</p><p>Most GPGPU successes stem from scientific computing or other areas with a homogeneous numerical computational component [<xref ref-type="bibr" rid="B17">17</xref>,<xref ref-type="bibr" rid="B18">18</xref>]. These applications are well suited for running on graphics hardware because they have high <italic>arithmetic intensity </italic>&#x02013; the ratio of time spent performing arithmetic to the time spent transferring data to and from memory [<xref ref-type="bibr" rid="B19">19</xref>]. In general, the applications that have performed well as a GPGPU application are those that can decompose their problems into highly independent components each having high arithmetic intensity [<xref ref-type="bibr" rid="B20">20</xref>]. Some bioinformatics applications with these properties have been successfully ported to graphics hardware. Liu <italic>et al</italic>. implemented the Smith-Waterman local sequence alignment algorithm to run on the nVidia GeForce 6800 GTO and GeForce 7800 GTX, and reported an approximate 16&#x000d7; speedup by computing the alignment score of multiple cells simultaneously [<xref ref-type="bibr" rid="B21">21</xref>]. Charalambous <italic>et al</italic>. ported an expensive loop from RAxML, an application for phylogenetic tree construction, and achieved a 1.2&#x000d7; speedup on the nVidia GeForce 5700 LE [<xref ref-type="bibr" rid="B22">22</xref>].</p><p>nVidia's new G80 architecture radically departs from the traditional vertex+fragment processor pipeline. It features a set of multiprocessors that each contain a number of stream processors (Figure <xref ref-type="fig" rid="F2">2</xref>). Graphics applications can use these as either vertex or fragment processors, and GPGPU applications can program them for general computation. All processors on a single multiprocessor simultaneously execute the same instruction, but different multiprocessors can execute different instructions. nVidia anticipated the benefits of such a unified architecture for GPGPU computing, and released the Compute Unified Device Architecture (CUDA) SDK to assist developers in creating non-graphics applications that run on the G80 and future GPUs. CUDA offers improved flexibility over previous GPGPU programming tools, and does not require application writers to recast operations in terms of geometric primitives, as was required by earlier GPGPU environments [<xref ref-type="bibr" rid="B23">23</xref>].</p><fig position="float" id="F2"><label>Figure 2</label><caption><p><bold>Simplified view of the nVidia G80 Architecture</bold>. This figure, inspired by a similar figure in [23] shows how the GPU is organized into several (N) multiprocessors, each containing multiple (M) stream processors that simultaneously execute the same instruction. Each processor can access the texture cache very quickly, but reads and writes to the onboard RAM have high latency.</p></caption><graphic xlink:href="1471-2105-8-474-2"/></fig><p>CUDA enables programmers to write programs that run on the GPU in a restricted form of the C programming language, and compiled into G80 bytecode. CUDA programs typically consist of a component that runs on the CPU, or <italic>host</italic>, and a smaller but computationally intensive component called the <italic>kernel </italic>that runs in parallel on the GPU (Figure <xref ref-type="fig" rid="F3">3</xref>). The kernel cannot access the CPU's main memory directly &#x02013; input data for the kernel must be copied to the GPU's on-board memory prior to invoking the kernel, and output data also must first be written to the GPU's memory. All memory used by the kernel must be preallocated, and the kernel cannot use recursion or other features requiring a stack, but loops and conditionals are allowed. Furthermore, the number of registers per multiprocessor is limited and the multiprocessor schedules fewer processors to compute simultaneously if the number of registers used per kernel is too high. Consequently, high-performance kernel code requires careful tuning to reduce the number of registers used and limit the amount of branching.</p><fig position="float" id="F3"><label>Figure 3</label><caption><p><bold>Typical GPGPU application flow</bold>. Input data for a GPGPU application must be copied to the GPU's memory along with a pre-allocated output buffer prior to invoking the GPU-based kernel. Output from the kernel is read back into main memory and reported to the user.</p></caption><graphic xlink:href="1471-2105-8-474-3"/></fig><p>The improved flexibility of CUDA does not solve the more fundamental problems caused by the G80's stream-computing organization: the relatively small cache and associated high memory latency for memory intensive programs. However, the G80's texture memory is cached to speed up memory intensive texture mapping operations, and can be used by GPGPU programs. GPGPU programs can pack their data structures into one-, two-, or three-dimensional arrays stored in texture memory, and thus use the cache for read-only memory accesses to these data structures [<xref ref-type="bibr" rid="B23">23</xref>]. Performance is further improved by utilizing one of several software techniques for maximizing the benefit offered by even a small cache. One such class of techniques involves reordering either the data in memory or the operations on those data to maximize data and temporal locality. Mellor-Crummey <italic>et al</italic>. reported significant speedup in particle interaction simulations, which feature highly irregular access patterns, by reordering both the locations of particles in memory and the order in which interactions were processed. They tested a reordering strategy based on space-filling curves, such as the Hilbert and Morton curves [<xref ref-type="bibr" rid="B24">24</xref>].</p></sec></sec><sec><title>Implementation</title><p>The MUMmerGPU algorithm performs parallelized exact string alignment on the GPU (Figure <xref ref-type="fig" rid="F4">4</xref>). First a suffix tree of the reference sequence is constructed on the CPU using Ukkonen's algorithm [<xref ref-type="bibr" rid="B13">13</xref>] and transfered to the GPU. Then the query sequences are transfered to the GPU, and are aligned to the tree on the GPU using the alignment algorithm described above. Alignment results are temporarily written to the GPU's memory, and then transfered in bulk to host RAM once the alignment kernel is complete for all queries. Finally, all maximal alignments longer than a user-supplied value (<italic>l</italic>) are reported by post-processing the raw alignment results on the CPU. The output format and many parameters of MUMmerGPU are identical to those of mummer (with the -maxmatch option), up to the order in which alignments appear in the output for each query, and thus MUMmerGPU can be used as a drop-in replacement for mummer. In particular, all programs in the NUCmer suite of programs that use the output of mummer, including those that extend the exact alignment seeds to larger inexact alignments, can take advantage of the GPU paralellization [<xref ref-type="bibr" rid="B4">4</xref>-<xref ref-type="bibr" rid="B6">6</xref>].</p><fig position="float" id="F4"><label>Figure 4</label><caption><p><bold>MUMmerGPU Algorithm</bold>. MUMmerGPU builds multiple suffix trees of the reference and partitions the query sequences into sets, called <italic>QueryBlocks</italic>, depending on the memory available on the GPU. Sequences within a given <italic>QueryBlock </italic>are aligned in parallel on the GPU.</p></caption><graphic xlink:href="1471-2105-8-474-4"/></fig><p>The G80 has a relatively small amount of on-board memory, so the data are partitioned into large blocks so that the reference suffix tree, query sequences, and output buffers will fit on the GPU. As of this writing, the amount of on-board memory for a G80 ranges from 256 MB to 768 MB. A suffix tree built from a large reference sequence, such as a human chromosome, will exceed this size, so MUMmerGPU builds <italic>k </italic>smaller suffix trees from overlapping segments of the reference. MUMmerGPU computes <italic>k </italic>at runtime to fill approximately one third of the total GPU device memory with tree data. The trees overlap in the reference sequence by the maximum query length <italic>m </italic>supported by MUMmerGPU (currently 8192 bp) to guarantee all alignments in the reference are found, but alignments in the overlapping regions are reported only once.</p><p>After building the trees, MUMmerGPU computes the amount of GPU memory available for storing query data and alignment results. The queries are read from disk in blocks that will fill the remaining memory, concatenated into a single large buffer (separated by null characters), and transferred to the GPU. An auxiliary 1D array, also transfered to the GPU, stores the offset of each query in the query buffer. Each multiprocessor on the GPU is assigned a subset of queries to process in parallel, depending on the number of multiprocessors and processors available. The executable code running on each processor, the <italic>kernel</italic>, aligns a single query sequence from the multiprocessor's subset to the reference. The kernel aligns the query to the reference by navigating the tree using the suffix-links to avoid reprocessing the same character of the query, as described above. Reverse complement alignments are computed using a second version of the kernel which reverse complements the query sequences on-the-fly while aligning, allowing for computing both forward and reverse alignments without any additional data transfer overhead. The output buffer contains a slot to record the alignment result for each of the <italic>m </italic>- <italic>l </italic>+ 1 substrings for a query of length <italic>m</italic>. The fixed size alignment result consists of the node id of the last visited node in the tree and length of the substring that exactly aligns. This information is sufficient to print all positions in the reference that exactly align the substring on the CPU.</p><p>After the kernel is complete for all the queries, the output buffer on the GPU is transfered to host RAM and the alignments are printed by the CPU. Each slot in the output buffer corresponds to a specific substring of a query. If multiple trees were built from the reference (<italic>k </italic>&#x0003e; 1), then the output slots for each tree are preserved until the queries in a block have been aligned against each tree. This way all of the alignments for a given query can be printed in a single block, following the syntax used by mummer.</p><sec><title>GPU Memory Layout</title><p>The suffix tree is "flattened" into two 2D textures, the node texture and the child texture. Each tree node is stored in a pair of 16-byte texels (texture elements) in these two textures. The node texture stores half the information for a node, including the start and end coordinates of the edge sequence in the reference, and the suffix link for the node. The remaining information for a node &#x02013; the pointers to its A, C, G &#x00026; T children &#x02013; is stored in the child texture, addressed in parallel to the node texture. An auxiliary table containing each node's edge length, sequence depth, parent pointer, and suffix number for leaf nodes, is stored in RAM and is used during the output phase.</p><p>In the CUDA architecture, a program can store read-only data as cached textures. The G80's proprietary caching scheme takes advantage of 2D locality common in texturing operations. Therefore, the algorithm attempts to optimize the 2D locality of the tree structure in these textures by organizing the nodes in 32 &#x000d7; 32 texel blocks as shown in Figure <xref ref-type="fig" rid="F5">5</xref>. Near the root of the tree (node depth <italic>&#x0003c;</italic>16), nodes are assigned using a level-order (breadth-first) traversal of the tree creating "wide" blocks of the tree. This ensures that all nodes near the root of the tree are placed in the first 32 &#x000d7; 32 texel blocks, and guarantees the children of a given node will be at (nearly) adjacent cells in the texture. This is useful because at this depth, loading a single 32 &#x000d7; 32 block for one kernel is likely to be reused for the other kernels running in parallel. Further from the root (depth &#x02265; 16), nodes are arranged in "tall" blocks so that a node, its children, grandchildren, and great-grandchildren are adjacently placed in the same (or adjacent) 32 &#x000d7; 32 block. As multiple queries are aligned against lower parts of the tree, it becomes less likely that their kernels will access many of the same nodes. Thus, the data reordering scheme attempts to increase the cache hit rate for a single thread. The exact specification of the G80's caching scheme is proprietary information, but empirically, this hybrid layout seems to maximize the cache hit rate near the root of the tree, and towards the leaves where the kernel access patterns are radically different.</p><fig position="float" id="F5"><label>Figure 5</label><caption><p><bold>Suffix Tree layout</bold>. The nodes of the suffix tree are rearranged into cache blocks to optimize 2D locality. Near the root of the tree, nodes of the same depth are placed into the same "wide" block. Futher down the tree, nodes from the same subtree are placed into the same "tall" block. MUMmerGPU uses blocks of 32 &#x000d7; 32 nodes, but for clarity, 8 nodes cache blocks are displayed here.</p></caption><graphic xlink:href="1471-2105-8-474-5"/></fig><p>The reference sequence for the tree is transferred to the GPU as a third 2D texture, and is reordered along a simple 2D space-filling curve to maximize the cache hit rate for subsequent accesses along a node's edge. The sequence is reordered so that beginning with the first character, every four characters in the reference become the topmost four characters in the columns of the 2D array. Once the array contains 4 &#x000d7; 65,536 characters, successive four-character chunks become the next four characters in the columns, left-to-right, and so on. We experimented with a variety of other data reordering schemes, including along a Morton curve and other space filling curves, and found this to have the best performance on several reference sequences. Altogether, using cache memory organized with the spacing-filing curves for the suffix tree and reference sequence improved the kernel execution speed by several fold.</p></sec><sec><title>Complexity of MUMmerGPU</title><p>MUMmerGPU constructs its suffix trees in <italic>O</italic>(<italic>n</italic>) time with Ukkonen's algorithm, where <italic>n </italic>is the length of the reference. The alignment kernel running on the card computes all exact substring alignments for each query in time linear in the length of the query. The kernel is an implementation of existing alignment methods [<xref ref-type="bibr" rid="B14">14</xref>], but with many independent instances running simultaneously on the GPU.</p><p>MUMmerGPU uses both GPU memory and main system memory. Suffix trees use an amount of memory linear in the length of the reference from which they are constructed [<xref ref-type="bibr" rid="B14">14</xref>]. The suffix trees in MUMmerGPU thus each occupy <italic>O</italic>(<italic>n/k </italic>+ <italic>m</italic>) space, where <italic>k </italic>is the number of overlapping trees specified by the user, and <italic>m </italic>is the maximum query length supported by MUMmerGPU. Note that for most expected uses of MUMmerGPU <italic>n </italic>&#x0226b; <italic>m</italic>. Only a fraction of that total space is actually transferred to the GPU. In the current implementation, 32 out of every 48 bytes per node are transferred. The remaining bytes are stored in the host-only auxiliary table used only for printing results by the CPU. For each query, MUMmerGPU transfers the null terminated query sequence prepended with a special mismatch character, along with two 4-byte entries in auxiliary tables used by the kernel. For a query of length <italic>m</italic>, and a minimum substring length <italic>l</italic>, <italic>m </italic>- <italic>l </italic>+ 1 output slots are reserved to record the query's substring alignments, and each output slot occupies 8 bytes. The total space required on both the CPU and the GPU for each query is 8(<italic>m </italic>- <italic>l </italic>+ 1) + (<italic>m </italic>+ 10) bytes. On a G80 with 768 MB of on-board RAM, there is sufficient RAM to store a tree for a 5 Mbp reference sequence, and 5 million 25 bp or 500,000 100 bp query sequences.</p></sec></sec><sec><title>Results and Discussion</title><p>We measured the relative performance of MUMmerGPU by comparing the execution time of the GPU and CPU version of the alignment code, and the total application runtime of MUMmerGPU versus the serial application mummer. The test machine has a 3.0 GHz dual-core Intel Xeon 5160 with 2 GB of RAM, and an nVidia GeForce 8800 GTX. The 8800 GTX has 768 MB of on-board RAM and a G80 with 16 multiprocessors, each of which has 8 stream processors. At the time of this writing, the retail price of the 8800 GTX card is $529, and a retail-boxed Intel Xeon 5160 CPU is $882 [<xref ref-type="bibr" rid="B25">25</xref>]. Input and output was to a local 15,000 RPM SATA disk. The machine was running Red Hat Enterprise Linux release 4 update 5 (32 bit), CUDA 1.0, and mummer 3.19.</p><p>We ported the MUMmerGPU alignment kernel to use the CPU instead of the GPU to isolate the benefit of using graphics hardware over running the same algorithm on the CPU. CUDA allows programmers to write in a variant of C, so porting MUMmerGPU to the CPU required only straightforward syntactic changes, and involved no algorithmic changes. Where the CUDA runtime invokes many instances of the kernel on the GPU simultaneously, the CPU executes each query in the block sequentially.</p><p>The first test scenario was to align synthetically constructed reads to a bacterial genome. We used synthetic reads in order to explore MUMmerGPU's performance in the absence of errors and over a wider variety of query lengths then are available with genuine reads. The synthetic test reads consisted of 50-, 100-, 200-, 400-, and 800-character substrings (uniformly randomly) sampled from the <italic>Bacillus anthracis </italic>genome (GenBank ID: <ext-link ext-link-type="gen" xlink:href="NC_003997.3">NC_003997.3</ext-link>). Thus, each read exactly aligns to the genome end-to-end at least once, and possibly more depending on the repeat content of the genome. When aligning each of the five sets of reads, we used <italic>l </italic>equal to the read size for the set. Each set contained exactly 250,000,000 base pairs of query sequence divided evenly among all the reads in the set.</p><p>The time for building the suffix tree, reading queries from disk, and printing alignment output is the same regardless of whether MUMmerGPU ran on the CPU or the GPU, since those parts of MUMmerGPU always run on the CPU. The actual sequence alignment portion of MUMmerGPU ran dramatically faster, over 10&#x000d7; faster, on the GPU, despite the added cost of transferring the tree and query data to the GPU. The speedup of MUMmerGPU (not including the costs mentioned above shared by both variants) running on the GPU over MUMmerGPU on the CPU is shown in Figure <xref ref-type="fig" rid="F6">6</xref>.</p><fig position="float" id="F6"><label>Figure 6</label><caption><p><bold>Speedup of MUMmerGPU on the GPU over the CPU</bold>. The decrease in speedup when processing error-free synthetic reads as read length increases is due to a combination of thread divergence and poor cache hit rate.</p></caption><graphic xlink:href="1471-2105-8-474-6"/></fig><p>For longer reads, the speedup of using the GPU is diminished, because of poor cache performance and thread divergence, both of which are acknowledged as potential performance problems on the G80 [<xref ref-type="bibr" rid="B23">23</xref>]. All queries begin at the root of the tree, and many queries will share common nodes on their paths in the tree. However, as the kernel travels deeper into the tree for longer reads, the texture elements stored in the cache are reused less often, thus reducing the cache hit rate, and increasing the overall average access time. In addition, even though queries are the same length, the alignment kernel may not visit the same number of nodes, nor spend the same amount of time comparing to edges, because edges in suffix trees have variable length. This creates divergence among the threads processing queries, and the multiprocessor will be forced to serialize their instruction streams. It is difficult to quantify the relative contribution of these effects, but it is likely that both are significant sources of performance loss.</p><p>In addition to the test with synthetic data, we also aligned reads from several recent sequencing projects against the genomes from which the reads were generated. The projects included <italic>Streptococcus suis </italic>sequenced with the Solexa/Illumina sequencer [<xref ref-type="bibr" rid="B26">26</xref>], multiple strains of <italic>Listeria monocytogenes </italic>sequenced using 454 pyrosequencing (Genome GenBank ID: <ext-link ext-link-type="gen" xlink:href="NC_003210.1">NC_003210.1</ext-link>, read TI numbers 1405533909 &#x02013; 1405634798, 1406562010 &#x02013; 1406781638, 1407073020 &#x02013; 1411183505, 1413490052 &#x02013; 1415592095, 1415816363 &#x02013; 1415903784) and <italic>Caenorhabditis briggsae </italic>sequenced with standard ABI 3730xl Sanger-type sequencing [<xref ref-type="bibr" rid="B27">27</xref>]. We aligned the reads against both strands of the chromosomal DNA for <italic>L. monocytogenes </italic>and <italic>S. suis</italic>, and against both strands of chromosome III of <italic>C. briggsae</italic>. Little data from Solexa/Illumina has been made public at the time of this writing, and the public data set available had only a single lane's worth of data. To represent the full set of reads from a full Solexa/Illumina run, we concatenated 10 copies of a publicly-available file containing 2,659,250 36 bp reads to form the <italic>S. suis </italic>query set. The reference sequence and queries in all three tests did not include ambiguous bases. For these three tasks, Table <xref ref-type="table" rid="T1">1</xref> shows the runtime parameters used and the overall speedup of MUMmerGPU over mummer. Figure <xref ref-type="fig" rid="F7">7</xref> shows the wall-clock time spent by MUMmerGPU in the various phases of the algorithm, including kernel execution and I/O between CPU and GPU.</p><table-wrap position="float" id="T1"><label>Table 1</label><caption><p>Runtime parameters and speedup for MUMmerGPU test workloads. MUMmerGPU is consistently more than 3 times faster than mummer for a variety of sequencing data.</p></caption><table frame="hsides" rules="groups"><thead><tr><td align="left">Reference</td><td align="left">Reference length (bp)</td><td align="center"># of queries</td><td align="center">Query length mean &#x000b1; stdev.</td><td align="center">Min alignment length (<italic>l</italic>)</td><td align="center"># of suffix trees (<italic>k</italic>)</td><td align="center">Speedup</td></tr></thead><tbody><tr><td align="left"><italic>C. briggsae Chr. III </italic>(Sanger)</td><td align="left">13,163,117</td><td align="center">2,357,666</td><td align="center">717.84 &#x000b1; 159.44</td><td align="center">100</td><td align="center">2</td><td align="center">3.71</td></tr><tr><td align="left"><italic>L. monocytogenes </italic>(454)</td><td align="left">2,944,528</td><td align="center">6,620,471</td><td align="center">200.54 &#x000b1; 60.51</td><td align="center">20</td><td align="center">1</td><td align="center">3.79</td></tr><tr><td align="left"><italic>S. suis </italic>(Illumina/Solexa)</td><td align="left">2,007,491</td><td align="center">26,592,500</td><td align="center">35.96 &#x000b1; 0.27</td><td align="center">20</td><td align="center">1</td><td align="center">3.47</td></tr></tbody></table></table-wrap><fig position="float" id="F7"><label>Figure 7</label><caption><p><bold>Breakdown of MUMmerGPU processing time</bold>. The stacked bar charts indicate the amount of time spent in each phase of the MUMmerGPU for the three test sets. Given a sufficiently large number of sequencing reads, the time spent building the suffix tree is small compared to time spent aligning queries.</p></caption><graphic xlink:href="1471-2105-8-474-7"/></fig><p>For each of the alignment tasks, MUMmerGPU was between 3.47 and 3.79 times faster than mummer. For <italic>C. briggsae</italic>, MUMmerGPU spent most of its time aligning queries on the GPU. Because we aligned all of the reads from the sequence project against chromosome III of the <italic>C. briggsae</italic>, many of the reads did not align anywhere in the reference. As a result, a relatively short amount of time was spent in writing alignment output to disk. For other alignments, such as for the <italic>L. monocytogenes </italic>and <italic>S. suis </italic>test sets, the output phase dominates the running time of MUMmerGPU. For these tasks, printing the output in parallel with aligning a block of queries would provide substantial speedup, as it would hide much of the time spent aligning queries on the card. We plan to adopt this strategy in a future release of MUMmerGPU.</p><p>Despite the performance hazards experienced for longer simulated reads, MUMmerGPU on the GPU consistently outperforms mummer on real sequencing data by more than a factor of three in wall-clock application running time. Unlike the idealized simulated reads, these reads are variable length and have sequencing error, which will cause further divergence in the kernel executions. Furthermore, the <italic>C. briggsae </italic>alignment required the use of a segmented suffix tree and associated data transfer overhead. In general, MUMmerGPU confers significant speedup over mummer on tasks in which many short queries are aligned to a single long reference.</p></sec><sec><title>Conclusion</title><p>Operations on the suffix tree have extremely low arithmetic intensity &#x02013; they consist mostly of following a series of pointers. Thus, sequence alignment with a suffix tree might be expected to be a poor candidate for a parallel GPGPU application. However, our results show that a significant speedup, as much as a 10-fold speedup, can be achieved through the use of cached texture memory and data reordering to improve access locality. This speedup is realized only for large sets of short queries, but these read characteristics are beginning to dominate the marketplace for genome sequencing. For example Solexa/Illumina sequencing machines create on the order of 20 million 50 bp reads in a single run. For a single human genotyping application, reads from a few such runs need to be aligned against the entire human reference genome. Thus our application should perform extremely well on workloads commonly found in the near future. The success of our application is in large part the result of the first truly general purpose GPU programming environment, CUDA, which allowed us to directly formulate and implement our algorithm in terms of suffix tree navigation and not geometric or graphics operations. This environment made it possible to efficiently utilize the highly parallel and high speed 8800 GTX. An 8800 GTX is similar in price to a single 3.0 Ghz Xeon core, but offers up to 3.79&#x000d7; speedup in total application runtime. Furthermore, in the near future, a common commodity workstation is likely to contain a CUDA compliant GPU that could be used without any additional cost.</p><p>Even though MUMmerGPU is a low arithmetic memory intensive program, and the size of the stream processor cache on the G80 is limited, MUMmerGPU achieved a significant speedup, in part, by reordering the nodes to match the access patterns and fully use the cache. We therefore expect with careful analysis of the access pattern, essentially any highly parallel algorithm to perform extremely well on a relatively inexpensive GPU, and anticipate widespread use of GPGPU and other highly parallel multicore technologies in the near future. We hope by making MUMmerGPU available open source, it will act as a roadmap for a wide class of bioinformatics algorithms for multi-processor environments.</p></sec><sec><title>Availability and requirements</title><p>Project name: MUMmerGPU</p><p>Project home page: <ext-link ext-link-type="uri" xlink:href="http://mummergpu.sourceforge.net"/></p><p>Operating system(s): Linux, UNIX</p><p>Programming language: C, C++, CUDA</p><p>Other requirements: nVidia G80 GPU, CUDA 1.0</p><p>License: Artistic License</p><p>Restrictions to use by non-academics: none.</p></sec><sec><title>Authors' contributions</title><p>MS and CT developed the software and wrote the manuscript together. AD and AV helped to draft and edit the manuscript. All authors read and approved the final manuscript.</p></sec></body><back><ack><sec><title>Acknowledgements</title><p>The authors would like to thank David Luebke from nVidia Research for providing an early release of CUDA, Julian Parkhill from the Sanger Institute for making the <italic>S. suis </italic>data available, Mihai Pop from CBCB for his assistance obtaining data, and Steven Salzberg from CBCB for editing the manuscript. This work was supported in part by National Institutes of Health grants R01-LM006845 and R01-LM007938, and National Science Foundation CISE RI grant CNS 04-03313.</p></sec></ack><ref-list><ref id="B1"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Myers</surname><given-names>EW</given-names></name><name><surname>Sutton</surname><given-names>GG</given-names></name><name><surname>Delcher</surname><given-names>AL</given-names></name><name><surname>Dew</surname><given-names>IM</given-names></name><name><surname>Fasulo</surname><given-names>DP</given-names></name><name><surname>Flanigan</surname><given-names>MJ</given-names></name><name><surname>Kravitz</surname><given-names>SA</given-names></name><name><surname>Mobarry</surname><given-names>CM</given-names></name><name><surname>Reinert</surname><given-names>KH</given-names></name><name><surname>Remington</surname><given-names>KA</given-names></name><name><surname>Anson</surname><given-names>EL</given-names></name><name><surname>Bolanos</surname><given-names>RA</given-names></name><name><surname>Chou</surname><given-names>HH</given-names></name><name><surname>Jordan</surname><given-names>CM</given-names></name><name><surname>Halpern</surname><given-names>AL</given-names></name><name><surname>Lonardi</surname><given-names>S</given-names></name><name><surname>Beasley</surname><given-names>EM</given-names></name><name><surname>Brandon</surname><given-names>RC</given-names></name><name><surname>Chen</surname><given-names>L</given-names></name><name><surname>Dunn</surname><given-names>PJ</given-names></name><name><surname>Lai</surname><given-names>Z</given-names></name><name><surname>Liang</surname><given-names>Y</given-names></name><name><surname>Nusskern</surname><given-names>DR</given-names></name><name><surname>Zhan</surname><given-names>M</given-names></name><name><surname>Zhang</surname><given-names>Q</given-names></name><name><surname>Zheng</surname><given-names>X</given-names></name><name><surname>Rubin</surname><given-names>GM</given-names></name><name><surname>Adams</surname><given-names>MD</given-names></name><name><surname>Venter</surname><given-names>JC</given-names></name></person-group><article-title>A Whole-Genome Assembly of Drosophila</article-title><source>Science</source><year>2000</year><volume>287</volume><fpage>2196</fpage><lpage>2204</lpage><pub-id pub-id-type="pmid">10731133</pub-id></citation></ref><ref id="B2"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Pop</surname><given-names>M</given-names></name><name><surname>Phillippy</surname><given-names>A</given-names></name><name><surname>Delcher</surname><given-names>AL</given-names></name><name><surname>Salzberg</surname><given-names>SL</given-names></name></person-group><article-title>Comparative genome assembly</article-title><source>Briefings in Bioinformatics</source><year>2004</year><volume>5</volume><fpage>237</fpage><lpage>248</lpage><pub-id pub-id-type="pmid">15383210</pub-id></citation></ref><ref id="B3"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Shaffer</surname><given-names>C</given-names></name></person-group><article-title>Next-generation sequencing outpaces expectations</article-title><source>Nat Biotechnol</source><year>2007</year><volume>25</volume><fpage>149</fpage><pub-id pub-id-type="pmid">17287734</pub-id></citation></ref><ref id="B4"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Kurtz</surname><given-names>S</given-names></name><name><surname>Phillippy</surname><given-names>A</given-names></name><name><surname>Delcher</surname><given-names>AL</given-names></name><name><surname>Smoot</surname><given-names>M</given-names></name><name><surname>Shumway</surname><given-names>M</given-names></name><name><surname>Antonescu</surname><given-names>C</given-names></name><name><surname>Salzberg</surname><given-names>SL</given-names></name></person-group><article-title>Versatile and open software for comparing large genomes</article-title><source>Genome Biol</source><year>2004</year><volume>5</volume><fpage>R12</fpage><pub-id pub-id-type="pmid">14759262</pub-id></citation></ref><ref id="B5"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Delcher</surname><given-names>AL</given-names></name><name><surname>Kasif</surname><given-names>S</given-names></name><name><surname>Fleischmann</surname><given-names>RD</given-names></name><name><surname>Peterson</surname><given-names>J</given-names></name><name><surname>White</surname><given-names>O</given-names></name><name><surname>Salzberg</surname><given-names>SL</given-names></name></person-group><article-title>Alignment of whole genomes</article-title><source>Nucleic Acids Res</source><year>1999</year><volume>27</volume><fpage>2369</fpage><lpage>76</lpage><pub-id pub-id-type="pmid">10325427</pub-id></citation></ref><ref id="B6"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Delcher</surname><given-names>AL</given-names></name><name><surname>Phillippy</surname><given-names>A</given-names></name><name><surname>Carlton</surname><given-names>J</given-names></name><name><surname>Salzberg</surname><given-names>SL</given-names></name></person-group><article-title>Fast algorithms for large-scale genome alignment and comparison</article-title><source>Nucleic Acids Res</source><year>2002</year><volume>30</volume><fpage>2478</fpage><lpage>2483</lpage><pub-id pub-id-type="pmid">12034836</pub-id></citation></ref><ref id="B7"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Atschul</surname><given-names>SF</given-names></name><name><surname>Gish</surname><given-names>W</given-names></name><name><surname>Miller</surname><given-names>W</given-names></name><name><surname>Myers</surname><given-names>EW</given-names></name><name><surname>Lipman</surname><given-names>DJ</given-names></name></person-group><article-title>Basic local alignment search tool</article-title><source>J Mol Biol</source><year>1990</year><volume>215</volume><fpage>403</fpage><lpage>410</lpage><pub-id pub-id-type="pmid">2231712</pub-id></citation></ref><ref id="B8"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Pearson</surname><given-names>W</given-names></name><name><surname>Lipman</surname><given-names>D</given-names></name></person-group><article-title>Improved tools for biological sequence comparison</article-title><source>Proc Natl Acad Sci USA</source><year>1988</year><volume>85</volume><fpage>2444</fpage><lpage>2448</lpage><pub-id pub-id-type="pmid">3162770</pub-id></citation></ref><ref id="B9"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Brudno</surname><given-names>M</given-names></name><name><surname>Do</surname><given-names>C</given-names></name><name><surname>Cooper</surname><given-names>G</given-names></name><name><surname>Kim</surname><given-names>M</given-names></name><name><surname>Davydov</surname><given-names>E</given-names></name><name><surname>Green</surname><given-names>E</given-names></name><name><surname>Sidow</surname><given-names>A</given-names></name><name><surname>Batzoglou</surname><given-names>S</given-names></name></person-group><article-title>LAGAN and Multi-LAGAN: efficient tools for large-scale alignment of genomic DNA</article-title><source>Genome Res</source><year>2003</year><volume>13</volume><fpage>721</fpage><lpage>731</lpage><pub-id pub-id-type="pmid">12654723</pub-id></citation></ref><ref id="B10"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Hohl</surname><given-names>M</given-names></name><name><surname>Kurtz</surname><given-names>S</given-names></name><name><surname>Ohlebusch</surname><given-names>E</given-names></name></person-group><article-title>Efficient multiple genome alignment</article-title><source>Bioinformatics</source><year>2002</year><volume>18</volume><fpage>S312</fpage><lpage>S320</lpage><pub-id pub-id-type="pmid">12169561</pub-id></citation></ref><ref id="B11"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Kurtz</surname><given-names>S</given-names></name><name><surname>Choudhuri</surname><given-names>J</given-names></name><name><surname>Ohlebusch</surname><given-names>E</given-names></name><name><surname>Schleiermacher</surname><given-names>C</given-names></name><name><surname>Stoye</surname><given-names>J</given-names></name><name><surname>Giegerich</surname><given-names>R</given-names></name></person-group><article-title>REPuter: the manifold applications of repeat analysis on a genomic scale</article-title><source>Nucleic Acids Res</source><year>2001</year><volume>29</volume><fpage>4633</fpage><lpage>4642</lpage><pub-id pub-id-type="pmid">11713313</pub-id></citation></ref><ref id="B12"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Weiner</surname><given-names>P</given-names></name></person-group><article-title>Linear pattern matching algorithms</article-title><source>Proceedings of the 14th IEEE Symposium on Switching and Automata Theory</source><year>1973</year><fpage>1</fpage><lpage>11</lpage></citation></ref><ref id="B13"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Ukkonen</surname><given-names>E</given-names></name></person-group><article-title>On-line construction of suffix-trees</article-title><source>Algorithmica</source><year>1995</year><volume>14</volume><fpage>249</fpage><lpage>260</lpage></citation></ref><ref id="B14"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Gusfield</surname><given-names>D</given-names></name></person-group><source>Algorithms on strings, trees, and sequences: computer science and computational biology</source><year>1997</year><publisher-name>New York: Cambridge University Press</publisher-name></citation></ref><ref id="B15"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Owens</surname><given-names>JD</given-names></name><name><surname>Luebke</surname><given-names>D</given-names></name><name><surname>Govindaraju</surname><given-names>N</given-names></name><name><surname>Harris</surname><given-names>M</given-names></name><name><surname>Kr&#x000fc;ger</surname><given-names>J</given-names></name><name><surname>Lefohn</surname><given-names>AE</given-names></name><name><surname>Purcell</surname><given-names>T</given-names></name></person-group><article-title>A Survey of General-Purpose Computation on Graphics Hardware</article-title><source>Computer Graphics Forum</source><year>2007</year><volume>26</volume><fpage>80</fpage><lpage>113</lpage></citation></ref><ref id="B16"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Govindaraju</surname><given-names>NK</given-names></name><name><surname>Larsen</surname><given-names>S</given-names></name><name><surname>Gray</surname><given-names>J</given-names></name><name><surname>Manocha</surname><given-names>D</given-names></name></person-group><article-title>A memory model for scientific algorithms on graphics processors</article-title><source>SC'06: Proceedings of the 2006 ACM/IEEE conference on Supercomputing</source><year>2006</year><publisher-name>New York, NY, USA: ACM Press</publisher-name><fpage>89</fpage></citation></ref><ref id="B17"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Harris</surname><given-names>MJ</given-names></name><name><surname>Coombe</surname><given-names>G</given-names></name><name><surname>Scheuermann</surname><given-names>T</given-names></name><name><surname>Lastra</surname><given-names>A</given-names></name></person-group><article-title>Physically-Based Visual Simulation on Graphics Hardware</article-title><source>Proc 2002 SIGGRAPH/Eurographics Workshop on Graphics Hardware</source><year>2002</year></citation></ref><ref id="B18"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Juekuan</surname><given-names>Y</given-names></name><name><surname>Yujuan</surname><given-names>W</given-names></name><name><surname>Yunfei</surname><given-names>C</given-names></name></person-group><article-title>GPU accelerated molecular dynamics simulation of thermal conductivities</article-title><source>J Comput Phys</source><year>2007</year><volume>221</volume><fpage>799</fpage><lpage>804</lpage></citation></ref><ref id="B19"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Dally</surname><given-names>WJ</given-names></name><name><surname>Labonte</surname><given-names>F</given-names></name><name><surname>Das</surname><given-names>A</given-names></name><name><surname>Hanrahan</surname><given-names>P</given-names></name><name><surname>Ahn</surname><given-names>JH</given-names></name><name><surname>Gummaraju</surname><given-names>J</given-names></name><name><surname>Erez</surname><given-names>M</given-names></name><name><surname>Jayasena</surname><given-names>N</given-names></name><name><surname>Buck</surname><given-names>I</given-names></name><name><surname>Knight</surname><given-names>TJ</given-names></name><name><surname>Kapasi</surname><given-names>UJ</given-names></name></person-group><article-title>Merrimac: Supercomputing with Streams</article-title><source>SC'03: Proceedings of the 2003 ACM/IEEE conference on Supercomputing</source><year>2003</year><publisher-name>Washington, DC, USA: IEEE Computer Society</publisher-name><fpage>35</fpage></citation></ref><ref id="B20"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Buck</surname><given-names>I</given-names></name></person-group><person-group person-group-type="editor"><name><surname>Pharr M</surname></name></person-group><article-title>Taking the Plunge into GPU Computing</article-title><source>GPU Gems 2</source><year>2005</year><publisher-name>Addison-Wesley</publisher-name><fpage>509</fpage><lpage>519</lpage></citation></ref><ref id="B21"><citation citation-type="other"><person-group person-group-type="author"><name><surname>Liu</surname><given-names>W</given-names></name><name><surname>Schmidt</surname><given-names>B</given-names></name><name><surname>Voss</surname><given-names>G</given-names></name><name><surname>Schroder</surname><given-names>A</given-names></name><name><surname>Muller-Wittig</surname><given-names>W</given-names></name></person-group><article-title>Bio-Sequence Database Scanning on a GPU</article-title><source>20th IEEE International Parallel &#x00026; Distributed Processing Symposium (IPDPS 2006) (HICOMB Workshop), Rhode Island, Greece</source><year>2006</year></citation></ref><ref id="B22"><citation citation-type="book"><person-group person-group-type="author"><name><surname>Charalambous</surname><given-names>M</given-names></name><name><surname>Trancoso</surname><given-names>P</given-names></name><name><surname>Stamatakis</surname><given-names>A</given-names></name></person-group><article-title>Initial Experiences Porting a Bioinformatics Application to a Graphics Processor</article-title><source>Proceedings of the 10th Panhellenic Conference on Informatics (PCI 2005)</source><year>2005</year><publisher-name>Volos, Greece: Springer LNCS</publisher-name><fpage>415</fpage><lpage>425</lpage></citation></ref><ref id="B23"><citation citation-type="other"><person-group person-group-type="author"><collab>nVidia</collab></person-group><article-title>nVidia Compute Unified Device Architecture (CUDA) Programming Guide, version 1.0</article-title><year>2007</year></citation></ref><ref id="B24"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Mellor-Crummey</surname><given-names>J</given-names></name><name><surname>Whalley</surname><given-names>D</given-names></name><name><surname>Kennedy</surname><given-names>K</given-names></name></person-group><article-title>Improving Memory Hierarchy Performance for Irregular Applications Using Data and Computation Reorderings</article-title><source>Int J Parallel Program</source><year>2001</year><volume>29</volume><fpage>217</fpage><lpage>247</lpage></citation></ref><ref id="B25"><citation citation-type="other"><article-title>Newegg.com</article-title><ext-link ext-link-type="uri" xlink:href="http://www.newegg.com"/></citation></ref><ref id="B26"><citation citation-type="other"><article-title>Streptococcus suis sequencing project</article-title><ext-link ext-link-type="uri" xlink:href="http://www.sanger.ac.uk/Projects/S_suis/"/></citation></ref><ref id="B27"><citation citation-type="journal"><person-group person-group-type="author"><name><surname>Stein</surname><given-names>LD</given-names></name><name><surname>Bao</surname><given-names>Z</given-names></name><name><surname>Blasiar</surname><given-names>D</given-names></name><name><surname>Blumenthal</surname><given-names>T</given-names></name><name><surname>Brent</surname><given-names>MR</given-names></name><name><surname>Chen</surname><given-names>N</given-names></name><name><surname>Chinwalla</surname><given-names>A</given-names></name><name><surname>Clarke</surname><given-names>L</given-names></name><name><surname>Clee</surname><given-names>C</given-names></name><name><surname>Coghlan</surname><given-names>A</given-names></name><name><surname>Coulson</surname><given-names>A</given-names></name><name><surname>D'Eustachio1</surname><given-names>P</given-names></name><name><surname>Fitch</surname><given-names>DHA</given-names></name><name><surname>Fulton</surname><given-names>LA</given-names></name><name><surname>Fulton</surname><given-names>RE</given-names></name><name><surname>Griffiths-Jones</surname><given-names>S</given-names></name><name><surname>Harris</surname><given-names>TW</given-names></name><name><surname>Hillier</surname><given-names>LW</given-names></name><name><surname>Kamath</surname><given-names>R</given-names></name><name><surname>Kuwabara</surname><given-names>PE</given-names></name><name><surname>Mardis</surname><given-names>ER</given-names></name><name><surname>Marra</surname><given-names>MA</given-names></name><name><surname>Miner</surname><given-names>TL</given-names></name><name><surname>Minx</surname><given-names>P</given-names></name><name><surname>Mullikin</surname><given-names>JC</given-names></name><name><surname>Plumb</surname><given-names>RW</given-names></name><name><surname>Rogers</surname><given-names>J</given-names></name><name><surname>Schein</surname><given-names>JE</given-names></name><name><surname>Sohrmann</surname><given-names>M</given-names></name><name><surname>Spieth</surname><given-names>J</given-names></name><name><surname>Stajich</surname><given-names>JE</given-names></name><name><surname>Wei</surname><given-names>C</given-names></name><name><surname>Willey</surname><given-names>D</given-names></name><name><surname>Wilson</surname><given-names>RK</given-names></name><name><surname>Durbin</surname><given-names>R</given-names></name><name><surname>Waterston</surname><given-names>RH</given-names></name></person-group><article-title>The Genome Sequence of Caenorhabditis briggsae: A Platform for Comparative Genomics</article-title><source>PLoS Biology</source><year>2003</year><volume>1</volume><pub-id pub-id-type="pmid">14624247</pub-id></citation></ref></ref-list></back></article>


